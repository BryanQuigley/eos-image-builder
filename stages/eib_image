#!/bin/bash -ex
# -*- mode: Shell-script; sh-basic-offset: 2; indent-tabs-mode: nil -*-
. "${EIB_BASELIB}"

# We do all fs preparation on the host disk, before then copying it into
# an image, in preparation for later development where the image will be sized
# dynamically based on how much data it includes.

mutable_deployment() {
  if [ -n "${OSTREE_DEPLOYMENT}" ]; then
    chattr -i "${OSTREE_DEPLOYMENT}"
  fi
}

cleanup_devices() {
  if [ -n "${img_loop}" ]; then
    partx -v -d "${img_loop}"
    eib_delete_loop "${img_loop}"
  fi
  unset img_loop
}

cleanup() {
  mutable_deployment || :
  eib_umount_all || :
  cleanup_devices || :
}
trap cleanup EXIT

recreate_dir "${EIB_OSTREE_CHECKOUT}"
REPOPATH=${EIB_OSTREE_CHECKOUT}/ostree/repo
BOOT=${EIB_OSTREE_CHECKOUT}/boot

# Bind mount the ostree repo and checkout to the same locations in the
# ostree chroot.
EIB_OSTREE_CHROOT="${EIB_OSTREE_TMPDIR}${EIB_OSTREE_REPODIR}"
EIB_OSTREE_CO_CHROOT="${EIB_OSTREE_TMPDIR}${EIB_OSTREE_CHECKOUT}"
mkdir -p "${EIB_OSTREE_CHROOT}" "${EIB_OSTREE_CO_CHROOT}"
eib_mount --bind "${EIB_OSTREE_REPODIR}" "${EIB_OSTREE_CHROOT}"
eib_mount --bind "${EIB_OSTREE_CHECKOUT}" "${EIB_OSTREE_CO_CHROOT}"
eib_mount -t sysfs sysfs "${EIB_OSTREE_TMPDIR}"/sys
eib_mount -t proc proc "${EIB_OSTREE_TMPDIR}"/proc
eib_mount --bind /dev/pts "${EIB_OSTREE_TMPDIR}"/dev/pts

tmp_ostree admin init-fs "${EIB_OSTREE_CHECKOUT}"
tmp_ostree admin --sysroot="${EIB_OSTREE_CHECKOUT}" os-init ${EIB_OSTREE_OS}
tmp_ostree --repo="${REPOPATH}" remote add ${EIB_OSTREE_OS} ${EIB_OSTREE_URL} \
  ${EIB_OSTREE_BRANCH_DEPLOY}
tmp_ostree --repo="${REPOPATH}" pull-local --disable-fsync \
  --remote=${EIB_OSTREE_OS} ${EIB_OSTREE_REPODIR} ${EIB_OSTREE_BRANCH_DEPLOY}

# Basic bootloader setup
if [[ "${EIB_ARCH}" == "armhf" ]]; then
  mkdir -p "${BOOT}"/loader.0
  ln -s loader.0 "${BOOT}"/loader
  # Empty uEnv.txt otherwise ostree gets upset
  > "${BOOT}"/loader/uEnv.txt
  ln -s loader/uEnv.txt "${BOOT}"/uEnv.txt
else
  # Assume grub for all other architectures
  mkdir -p "${BOOT}"/grub
  cp "${EIB_DATADIR}"/grub.cfg "${BOOT}"/grub/grub.cfg
fi

kargs=(--karg=rw --karg=splash \
    --karg=plymouth.ignore-serial-consoles --karg=quiet)
tmp_ostree admin --sysroot="${EIB_OSTREE_CHECKOUT}" deploy \
  --os=${EIB_OSTREE_OS} "${kargs[@]}" \
  ${EIB_OSTREE_OS}:${EIB_OSTREE_BRANCH_DEPLOY}

# There's no current symlink anymore, so query the deployment status.
# This will be the second parameter on the first line.
export OSTREE_CURRENT_DEPLOYMENT=$(tmp_ostree admin \
  --sysroot="${EIB_OSTREE_CHECKOUT}" status | awk '{print $2; exit}')
export OSTREE_DEPLOYMENT="${EIB_OSTREE_CHECKOUT}"/ostree/deploy/${EIB_OSTREE_OS}/deploy/${OSTREE_CURRENT_DEPLOYMENT}
export OSTREE_VAR="${EIB_OSTREE_CHECKOUT}"/ostree/deploy/${EIB_OSTREE_OS}/var

treeinfo="${EIB_TMPDIR}"/ostree.txt
echo "Branch ${EIB_OSTREE_BRANCH}" > ${treeinfo}
tmp_ostree --repo="${EIB_OSTREE_CHECKOUT}"/ostree/repo show \
  ${EIB_OSTREE_BRANCH_DEPLOY} >> ${treeinfo}

# All done with the tmp ostree, cleanup the mounts
eib_umount_all

# Output package list using the dpkg database from the deployment's /var
dpkgdir="${OSTREE_DEPLOYMENT}"/var/lib/dpkg
packageinfo="${EIB_TMPDIR}"/packages.txt
dpkg-query -W --admindir="${dpkgdir}" > "${packageinfo}"

run_hooks content "${OSTREE_DEPLOYMENT}"

create_image() {
  local outfile=$1

  # Create images according to data size, with 1GB free space.
  local img_size=$(du --block-size=1 -s "${EIB_OSTREE_CHECKOUT}")
  img_size=${img_size%$'\t'*}
  (( img_size += 1024 * 1024 * 1024 ))
  echo "Creating $1 image with size ${img_size}"

  local img=${EIB_TMPDIR}/image
  rm -f "${img}"
  truncate -s ${img_size} "${img}"

  # Partition table
  (
    # Empty space up to 1mb (for GPT, and for uboot on ARM)
    echo -n "start=2048, "

    case "${EIB_ARCH}" in
      i386|amd64)
        # EFI system partition
        echo "size=62MiB, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
        # GRUB BIOS BOOT partition
        echo "size=1MiB, type=21686148-6449-6E6F-744E-656564454649"
        ;;
    esac

    # Partition Type GUIDs
    # https://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec/
    case "${EIB_ARCH}" in
      i386|amd64)
        # Root Partition (x86-64)
        pt_guid="4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709"
        ;;
      armhf)
        # Root Partition (32-bit ARM)
        pt_guid="69DAD710-2CE4-4E3C-B16C-21A1D49ABED3"
        ;;
      *)
        echo "Unrecognized architecture ${EIB_ARCH}" >&2
        return 1
        ;;
    esac

    if [[ "${EIB_IMAGE_ROOTFS_RESIZE}" == "true" ]]; then
      # Remaining space is root fs, with special the special 55 attr as a
      # marker indicating the partition should be resized later
      echo "type=${pt_guid}, attrs=GUID:55"
    else
      echo "type=${pt_guid}"
    fi
  ) | sfdisk --force --label gpt "${img}"

  img_loop=$(losetup -f --show "${img}")
  eib_partx_scan "${img_loop}"

  case "${EIB_ARCH}" in
    i386|amd64)
      esp_loop=${img_loop}p1
      bios_boot_loop=${img_loop}p2
      root_loop=${img_loop}p3
      mkfs.vfat "${esp_loop}"
      ;;
    *)
      root_loop=${img_loop}p1
      ;;
  esac

  mke2fs -t ext4 -O dir_index,^huge_file -m1 -L ostree ${root_loop}
  ROOT="${EIB_BUILDDIR}"/mnt
  DEPLOY="${ROOT}"/ostree/deploy/${EIB_OSTREE_OS}/deploy/${OSTREE_CURRENT_DEPLOYMENT}
  mkdir -p "${ROOT}"
  eib_mount ${root_loop} "${ROOT}"
  eib_write_version_xattr "${ROOT}"

  case "${EIB_ARCH}" in
    i386|amd64)
      ESP="${ROOT}"/boot/efi
      mkdir -p "${ESP}"
      eib_mount ${esp_loop} "${ESP}"
      ;;
  esac

  # Copy contents into image, preserving attributes, timestamps, hardlinks, etc.
  cp -a "${EIB_OSTREE_CHECKOUT}"/* "${ROOT}"

  # Install bootloader
  case "${EIB_ARCH}" in
    armhf)
      case "${EIB_PLATFORM}" in
        odroidu2)
          # from hardkernel u-boot sd_fusing.sh
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/exynos4_odroid
          dd conv=notrunc if="${UBOOT_PATH}"/bl1.HardKernel of=${img} seek=1
          dd conv=notrunc if="${UBOOT_PATH}"/bl2.HardKernel of=${img} seek=31
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} seek=63
          dd conv=notrunc if="${UBOOT_PATH}"/tzsw.HardKernel of=${img} seek=2111
          ;;
        sqwerty)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/exynos4_sqwerty
          dd conv=notrunc if="${UBOOT_PATH}"/bl1.Sqwerty of=${img} seek=1
          dd conv=notrunc if="${UBOOT_PATH}"/bl2.Sqwerty of=${img} seek=31
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} seek=63
          dd conv=notrunc if="${UBOOT_PATH}"/tzsw.Sqwerty of=${img} seek=2111
          ;;
        ec100)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/meson8b_m201
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} bs=1 count=442
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} bs=17408 skip=1 seek=1
          ;;
        *)
          echo "Unrecognized armhf platform ${EIB_ARCH}" >&2
          return 1
          ;;
      esac
      ;;
    i386|amd64)
      # Bootloader bundle to support booting image files
      local boot_zip_dir=${EIB_TMPDIR}/boot_zip
      mkdir "${boot_zip_dir}"

      # MBR bootloader install
      > "${DEPLOY}"/img
      cp "${EIB_DATADIR}"/grub_embedded.cfg \
        "${EIB_DATADIR}"/grub_embedded_live.cfg \
        "${DEPLOY}"
      mount --bind "${img}" "${DEPLOY}"/img
      mount --bind "${ROOT}"/boot "${DEPLOY}"/boot
      mount --bind /dev "${DEPLOY}"/dev
      mount --bind /proc "${DEPLOY}"/proc

      # Capture BIOS-boot GRUB boot.img and core.img for live+installer USBs.
      #
      # grub-install invokes grub-mkimage, which writes a core.img file to
      # /boot/grub/i386-pc/; it then invokes grub-bios-setup to write this
      # file to the BIOS boot partition, and write an appropriate MBR (boot.img,
      # as shipped with GRUB, patched with the offset to the BIOS boot
      # partition).
      #
      # You might hope that we could just add core.img to $boot_zip, and later
      # dd it verbatim onto the BIOS boot partition, but it transpires that
      # grub-bios-setup modifies a few byte of core.img in passing, too. So we
      # actually install this flavour of GRUB, capture it, and later overwrite
      # it with the standard version.
      /usr/sbin/grub-install \
                   --modules="ext2 exfat ntfs part_msdos part_gpt search_fs_file search" \
                   --directory=/usr/lib/grub/i386-pc \
                   --config=/grub_embedded_live.cfg \
                   /dev/sda
      mkdir -p "${boot_zip_dir}/live"
      dd if="${img_loop}" of="${boot_zip_dir}/live/boot.img" bs=446 count=1
      dd if="${bios_boot_loop}" of="${boot_zip_dir}/live/core.img" \
                   bs="$(wc -c <"${DEPLOY}/boot/grub/i386-pc/core.img")" \
                   count=1

      # Create BIOS-boot GRUB core.img for images on NTFS. Windows only supports
      # BIOS-booting from MBR partition tables, so the pristine boot.img (with
      # offset "1 sector") is fine. When written to that sector, core.img is not
      # mangled by grub-bios-setup, either.
      mkdir -p "${boot_zip_dir}/ntfs"
      cp "${DEPLOY}/boot/grub/i386-pc/boot.img" "${boot_zip_dir}/ntfs"
      /usr/bin/grub-mkimage \
                   --directory=/usr/lib/grub/i386-pc \
                   --config=/grub_embedded_live.cfg \
                   --format=i386-pc \
                   --output="${boot_zip_dir}/ntfs/core.img" \
                   biosdisk ext2 ntfs part_msdos part_gpt search_fs_file
      # Assuming the worst case:
      # * the first partition starts at the second track
      # * a track is 64 512-byte sectors
      # * the MBR is one sector
      # then we have (64 - 1) * 512 == 32256 of space.
      local ntfs_core_img_bytes=$(wc -c <"${boot_zip_dir}/ntfs/core.img")
      local max_ntfs_core_img_bytes=32256
      if [ $ntfs_core_img_bytes -gt $max_ntfs_core_img_bytes ]; then
          echo "${boot_zip_dir}/ntfs/core.img is ${ntfs_core_img_bytes}" &>2
          echo "It must be <= ${max_ntfs_core_img_bytes}" >&2
          return 1
      fi

      # Capture second-stage config and modules
      cp -a "${DEPLOY}/boot/grub" "${boot_zip_dir}"

      # Install the real MBR bootloader
      chroot "${DEPLOY}" /usr/sbin/grub-install \
                   --modules="ext2 part_msdos part_gpt search_fs_type search" \
                   --directory=/usr/lib/grub/i386-pc \
                   --config=/grub_embedded.cfg \
                   /img
      umount "${DEPLOY}"/{boot,dev,img,proc}
      rm -f "${DEPLOY}"/img \
        "${DEPLOY}"/grub_embedded.cfg \
        "${DEPLOY}"/grub_embedded_live.cfg

      # UEFI bootloader install
      cp -a "${DEPLOY}"/boot/efi/EFI "${ESP}"
      (cd "${DEPLOY}"/boot/efi && zip -r "${boot_zip}" EFI)

      local boot_zip="$(eib_outfile boot.zip)"
      (cd "${boot_zip_dir}" && zip "${boot_zip}" -r *)
      rm -r "${boot_zip_dir}"
      sign_file "${boot_zip}" &
      ;;
    *)
      echo "Unrecognized architecture ${EIB_ARCH}" >&2
      return 1
      ;;
  esac

  eib_fix_boot_checksum "${img_loop}" "${DEPLOY}"

  # Restore the immutable attribute on the deployment root lost via cp
  chattr +i "${DEPLOY}"

  # Cleanup mounts and devices
  eib_umount_all
  cleanup_devices

  # Sign uncompressed image (used when installing from a live image)
  sign_file "${img}" "$(eib_outfile img.asc)" &

  # Publish uncompressed file size.
  stat -c "%s" "${img}" > "${outfile}.size"

  pigz --no-name -c "${img}" > ${outfile}
  # Sign compressed image (used to verify download)
  sign_file ${outfile} &

  # Copy ostree, package and config info to per-personality outdir.
  cp "${EIB_TMPDIR}"/ostree.txt "$(eib_outfile ostree.txt)"
  cp "${EIB_TMPDIR}"/packages.txt "$(eib_outfile packages.txt)"
  cp "${EIB_TMPDIR}"/config.ini "$(eib_outfile config.ini)"

  # Create split image for 2 disk systems if required.
  if [ "${EIB_IMAGE_SPLIT}" = true ]; then
    "${EIB_HELPERSDIR}"/split-image "${img}"
  fi

  # Await sign_file subprocesses
  wait
  rm -f "${img}"
}

echo "Create image for personality ${EIB_PERSONALITY}"

# Mount kernel filesystems into deployment for image hooks
eib_mount -t sysfs sysfs "${OSTREE_DEPLOYMENT}"/sys
eib_mount -t proc proc "${OSTREE_DEPLOYMENT}"/proc
eib_mount --bind /dev "${OSTREE_DEPLOYMENT}"/dev
eib_mount --bind /dev/pts "${OSTREE_DEPLOYMENT}"/dev/pts

# Bind mount OS /var over deployment's /var for image hooks
eib_mount --bind "${OSTREE_VAR}" "${OSTREE_DEPLOYMENT}"/var

# Bind mount the checkout over deployment's /sysroot, so the ostree repo
# is available for image hooks
eib_mount --bind "${EIB_OSTREE_CHECKOUT}" "${OSTREE_DEPLOYMENT}"/sysroot

recreate_dir "${EIB_OUTDIR}"
run_hooks image "${OSTREE_DEPLOYMENT}"
eib_umount_all
create_image "$(eib_outfile img.gz)"

# Make the deployment root mutable to delete it
mutable_deployment

rm -rf "${EIB_OSTREE_CHECKOUT}"
