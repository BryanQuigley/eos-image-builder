#!/bin/bash -ex
# -*- mode: Shell-script; sh-basic-offset: 2; indent-tabs-mode: nil -*-
. "${EIB_BASELIB}"

# We do all fs preparation on the host disk, before then copying it into
# an image, in preparation for later development where the image will be sized
# dynamically based on how much data it includes.

mutable_deployment() {
  if [ -n "${OSTREE_DEPLOYMENT}" ]; then
    chattr -i "${OSTREE_DEPLOYMENT}"
  fi
}

kill_procs() {
  if [ -n "${OSTREE_DEPLOYMENT}" ]; then
    "${EIB_HELPERSDIR}"/kill-chroot-procs "${OSTREE_DEPLOYMENT}"
  fi
}

cleanup_devices() {
  if [ -n "${img_loop}" ]; then
    partx -v -d "${img_loop}"
    eib_delete_loop "${img_loop}"
  fi
  unset img_loop
}

cleanup() {
  mutable_deployment || :
  kill_procs || :
  eib_umount_all || :
  cleanup_devices || :
}
trap cleanup EXIT

recreate_dir "${EIB_OSTREE_CHECKOUT}"
REPOPATH=${EIB_OSTREE_CHECKOUT}/ostree/repo
BOOT=${EIB_OSTREE_CHECKOUT}/boot

ostree admin init-fs "${EIB_OSTREE_CHECKOUT}"
ostree admin --sysroot="${EIB_OSTREE_CHECKOUT}" os-init ${EIB_OSTREE_OS}
ostree --repo="${REPOPATH}" remote add ${EIB_OSTREE_REMOTE} \
  ${EIB_OSTREE_URL} ${EIB_OSTREE_BRANCH_DEPLOY}
ostree --repo="${REPOPATH}" pull-local --disable-fsync \
  --remote=${EIB_OSTREE_REMOTE} ${EIB_OSTREE_REPODIR} ${EIB_OSTREE_BRANCH_DEPLOY}

# Basic bootloader setup
if [[ "${EIB_ARCH}" == "armhf" ]]; then
  mkdir -p "${BOOT}"/loader.0
  ln -s loader.0 "${BOOT}"/loader
  # Empty uEnv.txt otherwise ostree gets upset
  > "${BOOT}"/loader/uEnv.txt
  ln -s loader/uEnv.txt "${BOOT}"/uEnv.txt
else
  # Assume grub for all other architectures
  mkdir -p "${BOOT}"/grub
fi

kargs=(--karg=rw --karg=splash \
    --karg=plymouth.ignore-serial-consoles --karg=loglevel=2)
ostree admin --sysroot="${EIB_OSTREE_CHECKOUT}" deploy \
  --os=${EIB_OSTREE_OS} "${kargs[@]}" \
  ${EIB_OSTREE_REMOTE}:${EIB_OSTREE_BRANCH_DEPLOY}

# Set the repo add-remotes-config-dir option to false. This prevents
# ostree remotes from being added in /etc/ostree/remotes.d, which breaks
# flatpak due to the way it manages remotes. This can probably be
# removed later when ostree has a coherent way to modify existing
# remotes and all our ostree users are using it.
#
# https://phabricator.endlessm.com/T19077
ostree --repo="${REPOPATH}" config set core.add-remotes-config-dir false

# There's no current symlink anymore, so query the deployment status.
# This will be the second parameter on the first line.
export OSTREE_CURRENT_DEPLOYMENT=$(ostree admin \
  --sysroot="${EIB_OSTREE_CHECKOUT}" status | awk '{print $2; exit}')
export OSTREE_DEPLOYMENT="${EIB_OSTREE_CHECKOUT}"/ostree/deploy/${EIB_OSTREE_OS}/deploy/${OSTREE_CURRENT_DEPLOYMENT}
export OSTREE_VAR="${EIB_OSTREE_CHECKOUT}"/ostree/deploy/${EIB_OSTREE_OS}/var

treeinfo="${EIB_TMPDIR}"/ostree.txt
echo "Branch ${EIB_OSTREE_BRANCH}" > ${treeinfo}
ostree --repo="${EIB_OSTREE_CHECKOUT}"/ostree/repo show \
  ${EIB_OSTREE_BRANCH_DEPLOY} >> ${treeinfo}

# Output package list using the dpkg database from the deployment's /var
dpkgdir="${OSTREE_DEPLOYMENT}"/var/lib/dpkg
packageinfo="${EIB_TMPDIR}"/packages.txt
dpkg-query -W --admindir="${dpkgdir}" > "${packageinfo}"

# Add package info to manifest using helper. This needs to be run here
# rather than in an image hook because the dpkg database will be masked
# by the OS /var mount.
pkg_manifest="${EIB_MANIFESTDIR}"/packages.json
"${EIB_HELPERSDIR}"/packages-manifest > "${pkg_manifest}"

run_hooks content "${OSTREE_DEPLOYMENT}"

create_image() {
  local outfile=$1

  # Create images according to data size with additional free space. The
  # extra free space is used for 2 reasons:
  #
  # 1. The du estimate tends to be low compared to the space actually
  #    used by the copy.
  # 2. We want to boot without a totally full disk even though the
  #    partitions and file systems are expanded on first boot.
  #
  # The free space is the minimum of 5% of calculated size or 1GB,
  # rounded down to the nearest 512-byte sector.
  local img_size=$(du --block-size=1 -s "${EIB_OSTREE_CHECKOUT}")
  img_size=${img_size%$'\t'*}
  local extra_size=$((img_size * 5 / 100))
  local min_extra_size=$((2 ** 30))
  (( extra_size < min_extra_size )) && extra_size=${min_extra_size}
  (( img_size += extra_size ))
  (( img_size -= img_size % 512 ))
  echo "Creating $1 image with size ${img_size}"

  local img="${EIB_TMPDIR}/${EIB_OUTVERSION}.img"
  rm -f "${img}"
  truncate -s ${img_size} "${img}"

  (
    # Empty space up to 1mb (for GPT, and for uboot on ARM)
    echo -n "start=2048, "

    case "${EIB_ARCH}" in
      i386|amd64)
        # EFI system partition
        echo "size=62MiB, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
        # GRUB BIOS BOOT partition
        echo "size=1MiB, type=21686148-6449-6E6F-744E-656564454649"
        ;;
    esac

    if [ "${EIB_IMAGE_PARTITION_TABLE}" == "dos" ]; then
      part_type="83"
    else
      # Partition Type GUIDs
      # https://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec/
      case "${EIB_ARCH}" in
        i386|amd64)
          # Root Partition (x86-64)
          part_type="4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709"
          ;;
        armhf)
          # Root Partition (32-bit ARM)
          part_type="69DAD710-2CE4-4E3C-B16C-21A1D49ABED3"
          ;;
        *)
          echo "Unrecognized architecture ${EIB_ARCH}" >&2
          return 1
          ;;
      esac
    fi

    if [[ "${EIB_IMAGE_ROOTFS_RESIZE}" == "true" ]]; then
      # Remaining space is root fs, with special the special 55 attr as a
      # marker indicating the partition should be resized later
      # attrs=... is unused for DOS partition table so it's safe to leave it here
      echo "type=${part_type}, attrs=GUID:55"
    else
      echo "type=${part_type}"
    fi
  ) | sfdisk --force --label "${EIB_IMAGE_PARTITION_TABLE}" "${img}"

  if [ "${EIB_IMAGE_PARTITION_TABLE}" == "dos" ] && [ "${EIB_IMAGE_ROOTFS_RESIZE}" == "true" ]; then
    # With the latest 'sfdisk' we are not allowed anymore to create a 0B partition
    # Bypass this limitation directly hacking into the MBR to set the marker
    printf "\xdd" | dd of=${img} bs=1 count=1 seek=498 conv=notrunc
  fi

  img_loop=$(losetup -f --show "${img}")
  eib_partx_scan "${img_loop}"

  ROOT="${EIB_TMPDIR}"/mnt
  DEPLOY="${ROOT}"/ostree/deploy/${EIB_OSTREE_OS}/deploy/${OSTREE_CURRENT_DEPLOYMENT}

  case "${EIB_ARCH}" in
    i386|amd64)
      esp_loop=${img_loop}p1
      bios_boot_loop=${img_loop}p2
      root_loop=${img_loop}p3
      ext4_opts="dir_index,^huge_file"
      ESP="${ROOT}"/boot/efi
      mkfs.vfat "${esp_loop}"
      ;;
    *)
      # On ARM disable 64bit ext4 option
      ext4_opts="dir_index,^huge_file,^64bit"
      root_loop=${img_loop}p1
      ;;
  esac

  local readahead_size="$EIB_TMPDIR/readahead-size"
  local readahead_files=
  local root_size_kib=

  if [[ "$EIB_IMAGE_REORDER" == true && -e "$readahead_size" ]]; then
    # Created by hooks/image/50-readahead, if run.  Initially create the
    # filesystem with just enough space to hold files used during first boot,
    # with some extra for filesystem overhead and to reduce fragmentation.
    readahead_files="$EIB_TMPDIR/readahead-files.txt"
    if [[ ! -e "$readahead_files" ]]; then
      echo "$readahead_size exists but $readahead_files does not" >&2
      return 1
    fi

    root_size_kib=$(( $(cat "$readahead_size") * 12 / 10240 ))
  fi

  mke2fs -t ext4 -O ${ext4_opts} -m1 -L ostree -T default \
    ${root_loop} $root_size_kib
  mkdir -p "${ROOT}"
  eib_mount ${root_loop} "${ROOT}"

  if [[ "$readahead_files" ]]; then
    # First, copy only files used during boot process. This ensures they are
    # mostly contitugous at the start of the partition.
    rsync -aHAX --files-from="$readahead_files" \
      "${EIB_OSTREE_CHECKOUT}/" "${ROOT}/"
    if [[ -n "$ESP" && -d "$ESP" ]]; then
      echo "Files in the ESP should not be in readahead, but $ESP exists" >&2
      return 1
    fi

    # Now grow the filesystem to the full size of the partition
    eib_umount "$ROOT"

    e2fsck -f -p "$root_loop"
    resize2fs "$root_loop"

    # Once more for luck!
    e2fsck -f -p "$root_loop"
    eib_mount ${root_loop} "${ROOT}"
  fi

  if [ -n "$ESP" ]; then
      mkdir -p "${ESP}"
      eib_mount ${esp_loop} "${ESP}"
  fi

  # Copy the remaining files -- or all files, if we have no readahead file --
  # preserving attributes, timestamps, hardlinks, etc.
  #
  # We expect that many files in the readahead set have at least one other
  # hardlink (in the ostree repo), so need to take care to preserve those
  # hardlinks and not to move the file later in the disk in the process.
  # --no-inc-recursive makes rsync scan the whole tree to find hardlinks before
  # copying, and its use in combination with -H is documented to do what we
  # want. This appears to work correctly, based on running debugfs's
  # dump_extents and stat on each file in the readahead set after the first and
  # second passes.
  rsync -aHAX --update --no-inc-recursive "${EIB_OSTREE_CHECKOUT}/" "${ROOT}/"

  eib_write_version_xattr "${ROOT}"

  # Report on the free space
  df --block-size=1 "${ROOT}"

  # Make the deployment root mutable and delete the checkout since it's
  # no longer needed after this. Unset checkout derived variables so we
  # don't try to operate on them later (e.g., making a non-existent
  # OSTREE_DEPLOYMENT mutable at exit).
  mutable_deployment
  rm -rf "${EIB_OSTREE_CHECKOUT}"
  unset OSTREE_DEPLOYMENT OSTREE_VAR

  # Begin the images manifest fragment
  img_manifest="${EIB_MANIFESTDIR}"/images
  cat > "${img_manifest}" <<EOF
{
  "images": {
EOF

  # Install bootloader
  case "${EIB_ARCH}" in
    armhf)
      case "${EIB_PLATFORM}" in
        odroidu2)
          # from hardkernel u-boot sd_fusing.sh
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/exynos4_odroid
          dd conv=notrunc if="${UBOOT_PATH}"/bl1.HardKernel of=${img} seek=1
          dd conv=notrunc if="${UBOOT_PATH}"/bl2.HardKernel of=${img} seek=31
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} seek=63
          dd conv=notrunc if="${UBOOT_PATH}"/tzsw.HardKernel of=${img} seek=2111
          ;;
        sqwerty)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/exynos4_sqwerty
          dd conv=notrunc if="${UBOOT_PATH}"/bl1.Sqwerty of=${img} seek=1
          dd conv=notrunc if="${UBOOT_PATH}"/bl2.Sqwerty of=${img} seek=31
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} seek=63
          dd conv=notrunc if="${UBOOT_PATH}"/tzsw.Sqwerty of=${img} seek=2111
          ;;
        ec100)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/meson8b_m201
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} bs=1 count=442
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} bs=17408 skip=1 seek=1
          ;;
        s905x)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/s905x
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin.padded of=${img} bs=1 count=442
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin.padded of=${img} bs=512 skip=1 seek=1
          ;;
        *)
          echo "Unrecognized armhf platform ${EIB_ARCH}" >&2
          return 1
          ;;
      esac
      ;;
    i386|amd64)
      # MBR bootloader install
      > "${DEPLOY}"/img
      mount --bind "${img}" "${DEPLOY}"/img
      mount --bind "${ROOT}"/boot "${DEPLOY}"/boot
      mount --bind /dev "${DEPLOY}"/dev
      mount --bind /proc "${DEPLOY}"/proc
      mount --bind /sys "${DEPLOY}"/sys

      # Install the real MBR bootloader
      chroot "${DEPLOY}" /usr/sbin/grub-install \
                   --modules="ext2 part_msdos part_gpt search" \
                   --directory=/usr/lib/grub/i386-pc \
                   --config=/usr/lib/grub/conf/grub_embedded_bios.cfg \
                   /img

      # Copy grub.cfg
      cp "${DEPLOY}/usr/lib/grub/conf/grub.cfg" "${DEPLOY}/boot/grub/grub.cfg"

      if [ "$EIB_IMAGE_BOOT_ZIP" == "true" ]; then
        local boot_zip_dir=${EIB_TMPDIR}/boot_zip
        mkdir "${boot_zip_dir}"

        # Generate GRUB standalone images and eosldr
        "${EIB_HELPERSDIR}"/create-grub-images "${DEPLOY}" "${boot_zip_dir}"

        # Capture second-stage config and modules
        cp -a "${DEPLOY}/boot/grub" "${boot_zip_dir}"
      fi

      "${EIB_HELPERSDIR}"/kill-chroot-procs "${DEPLOY}"
      umount "${DEPLOY}"/{boot,dev,img,proc,sys}
      rm -f "${DEPLOY}"/img

      # UEFI bootloader install
      cp -r "${DEPLOY}"/boot/efi/EFI "${ESP}"

      if [ "$EIB_IMAGE_BOOT_ZIP" == "true" ]; then
        # Capture EFI GRUB for both live+installer and dual-boot image boots.
        #
        # From 3.1.x onwards, our ESP has the following layout:
        #
        # EFI/
        #   endless/
        #     grubx64.efi
        #     shim.efi
        #     BOOT.CSV
        #     MokManager.efi
        #   BOOT/
        #     bootx64.efi  - identical to shim.efi
        #     fallback.efi
        #
        # However, the installer for Windows, eos-write-live-image from
        # eos-meta, and helpers/create-iso in this repository all expect the
        # following layout in boot.zip:
        #
        # EFI/
        #   BOOT/
        #     bootx64.efi
        #     grubx64.efi
        #     MokManager.efi
        #
        # For dual-boot installs, we copy the entire contents of EFI/BOOT to
        # EFI/Endless on the ESP, and creates a boot entry for
        # EFI/Endless/bootx64.efi. For ISOs and live USBs, we just copy the
        # whole of EFI from boot.zip to the ESP. So for backwards-compatibility
        # in the dual-boot case, and simplicity in the ISO/live case, we
        # arrange for EFI/ to have the right structure:
        mkdir -p "${boot_zip_dir}/EFI/BOOT"
        cp \
          "${DEPLOY}"/boot/efi/EFI/BOOT/bootx64.efi \
          "${DEPLOY}"/boot/efi/EFI/BOOT/bootia32.efi \
          "${DEPLOY}"/boot/efi/EFI/endless/MokManager.efi \
          "${DEPLOY}"/boot/efi/EFI/endless/grubx64.efi \
          "${boot_zip_dir}/EFI/BOOT"

        # In case we want to use the additional files in a future release of
        # the installer, we include just those files in a different directory.
        # (In the past we created "EFI2" with the full contents of the ESP but
        # triplicating Shim and duplicating the 64-bit GRUB added 50% to the
        # boot.zip size, and this directory was never actually used.)
        mkdir -p "${boot_zip_dir}/EFI3/BOOT" "${boot_zip_dir}/EFI3/endless"
        cp "${DEPLOY}"/boot/efi/EFI/BOOT/fallback.efi "${boot_zip_dir}/EFI3/BOOT"
        cp "${DEPLOY}"/boot/efi/EFI/endless/BOOT.CSV "${boot_zip_dir}/EFI3/endless"

        # Bundle all GRUB versions up for distribution
        local boot_zip="$(eib_outfile boot.zip)"
        (cd "${boot_zip_dir}" && zip "${boot_zip}" -r *)
        rm -r "${boot_zip_dir}"
        sign_file "${boot_zip}" &

        # Generate manifest information
        local boot_zip_name=$(basename "${boot_zip}")
        local boot_zip_size=$(stat -c "%s" "${boot_zip}")
        local boot_zip_signature="${boot_zip_name}.asc"
        cat >> "${img_manifest}" <<EOF
    "boot": {
      "file": "${boot_zip_name}",
      "compressed_size": ${boot_zip_size},
      "compression_type": "zip",
      "signature": "${boot_zip_signature}"
    },
EOF
      else
        # No boot.zip means this is eosinstaller, not an installable image.
        # Since this will only be used on removable media, it should not
        # include fallback.efi, which alters the system's BootOrder. In effect,
        # we are recreating the layout in boot.zip/EFI, only on the real ESP.
        rm "${ESP}/EFI/BOOT/fallback.efi"
        mv \
          "${ESP}/EFI/endless/MokManager.efi" \
          "${ESP}/EFI/endless/grubx64.efi" \
          "${ESP}/EFI/BOOT/"
        rm -r "${ESP}/EFI/endless"
      fi
      ;;
    *)
      echo "Unrecognized architecture ${EIB_ARCH}" >&2
      return 1
      ;;
  esac

  eib_fix_boot_checksum "${img_loop}" "${DEPLOY}"

  # Read OS version from ostree deployment before we unmount it
  local version=$(. ${DEPLOY}/etc/os-release && echo ${VERSION})

  # Restore the immutable attribute on the deployment root lost via cp
  chattr +i "${DEPLOY}"

  # Cleanup mounts and devices
  eib_umount_all
  cleanup_devices

  # Sign uncompressed image (used when installing from a live image)
  local img_asc="$(eib_outfile img.asc)"
  sign_file "${img}" "${img_asc}" &

  # Publish uncompressed file size.
  local img_extracted_size=$(stat -c "%s" "${img}")
  echo "${img_extracted_size}" > "${outfile}.size"

  # Compress image file.
  eib_compress_image "${img}" "${outfile}"

  # Sign compressed image (used to verify download)
  sign_file ${outfile} &

  # Copy ostree, package and config info to per-personality outdir.
  cp "${EIB_TMPDIR}"/ostree.txt "$(eib_outfile ostree.txt)"
  cp "${EIB_TMPDIR}"/packages.txt "$(eib_outfile packages.txt)"
  cp "${EIB_TMPDIR}"/config.ini "$(eib_outfile config.ini)"

  # Create split image for 2 disk systems if required.
  if [ "${EIB_IMAGE_SPLIT}" = true ]; then
    "${EIB_HELPERSDIR}"/split-image "${img}"
  fi

  # Await sign_file subprocesses
  wait

  # Create ISO if required. This requires the uncompressed image, its
  # signature, and the signature for boot.zip. In theory we could `wait` only
  # for those two signatures and allow compressing the image and signing it to
  # happen in parallel with creating the ISO.
  if [ "${EIB_IMAGE_ISO}" == true ]; then
    "${EIB_HELPERSDIR}"/create-iso "${version}" "$(eib_outfile iso)" \
      "${img}" "${boot_zip}" "${img_asc}" "${boot_zip}.asc"
  fi

  # Remove uncompressed image, if not already deleted by helpers/create-iso
  rm -f "${img}"

  # Finish image manifest info
  local img_name=$(basename "${outfile}")
  local img_compressed_size=$(stat -c "%s" "${outfile}")
  local img_signature="${img_name}.asc"
  cat >> "${img_manifest}" <<EOF
    "full": {
      "file": "${img_name}",
      "extracted_size": ${img_extracted_size},
      "compressed_size": ${img_compressed_size},
      "compression_type": "${EIB_IMAGE_COMPRESSION}",
      "signature": "${img_signature}"
    }
  }
}
EOF
}

echo "Create image for personality ${EIB_PERSONALITY}"

# Mount the deployment directory over itself so / is a real mount in the
# chroot. This is needed for bubblewrap, which wants to mark the / mount
# as a slave.
eib_mount --bind "${OSTREE_DEPLOYMENT}" "${OSTREE_DEPLOYMENT}"

# Mark the hook root mount private. This has 2 benefits:
#
# 1. Any mounts placed under it will not leak out to the parent mount.
#    That keeps aliased mounts from showing up elsewhere in the system.
#
# 2. Bubblewrap uses pivot_root, which requires that the old root is not
#    a shared mount.
mount --make-private "${OSTREE_DEPLOYMENT}"

# Finally, pivot_root also requires that the parent of the old root is
# not a shared mount. Bind mount the hook root over itself again so the
# parent is the above private mount.
#
# See https://github.com/projectatomic/bubblewrap/issues/135.
eib_mount --bind "${OSTREE_DEPLOYMENT}" "${OSTREE_DEPLOYMENT}"

# Mount kernel filesystems into deployment for image hooks
eib_mount -t sysfs sysfs "${OSTREE_DEPLOYMENT}"/sys
eib_mount -t proc proc "${OSTREE_DEPLOYMENT}"/proc
eib_mount --bind /dev "${OSTREE_DEPLOYMENT}"/dev
eib_mount --bind /dev/pts "${OSTREE_DEPLOYMENT}"/dev/pts

# Mount a tmpfs at /tmp so that hooks can use it without persisting to
# the image
eib_mount -t tmpfs tmpfs "${OSTREE_DEPLOYMENT}"/tmp

# Bind mount OS /var over deployment's /var for image hooks
eib_mount --bind "${OSTREE_VAR}" "${OSTREE_DEPLOYMENT}"/var

# Bind mount the checkout over deployment's /sysroot, so the ostree repo
# is available for image hooks
eib_mount --bind "${EIB_OSTREE_CHECKOUT}" "${OSTREE_DEPLOYMENT}"/sysroot

# Bind mount the cache and source directories into the deployment so
# chroot hooks can access them
export EIB_CACHEDIR_CHROOT=/tmp/eos-image-builder
export EIB_SRCDIR_CHROOT=${EIB_CACHEDIR_CHROOT}/src
mkdir -p "${OSTREE_DEPLOYMENT}${EIB_CACHEDIR_CHROOT}" \
      "${OSTREE_DEPLOYMENT}${EIB_SRCDIR_CHROOT}"
eib_mount --bind "${EIB_CACHEDIR}" \
          "${OSTREE_DEPLOYMENT}${EIB_CACHEDIR_CHROOT}"
eib_mount --bind "${EIB_SRCDIR}" \
          "${OSTREE_DEPLOYMENT}${EIB_SRCDIR_CHROOT}"

# Copy in the host's /etc/resolv.conf so the one from the ostree (if it
# exists) is not used and DNS can be resolved.
cp -f /etc/resolv.conf "${OSTREE_DEPLOYMENT}"/etc/resolv.conf

# /usr/local is a symlink to /var/local in the ostree, but /var/local
# doesn't exist yet since it's created from systemd-tmpfiles at runtime.
# Create it now so that hooks can populate /usr/local.
if [ -L "${OSTREE_DEPLOYMENT}"/usr/local ]; then
  usr_local_link=$(readlink "${OSTREE_DEPLOYMENT}"/usr/local)
  if [ "${usr_local_link::1}" = / ]; then
    # Absolute path, prepend the deployment root
    usr_local_target="${OSTREE_DEPLOYMENT}${usr_local_link}"
  else
    # Relative path, prepend the deployment's /usr
    usr_local_target="${OSTREE_DEPLOYMENT}/usr/${usr_local_link}"
  fi

  mkdir -p "${usr_local_target}"
fi

recreate_dir "${EIB_OUTDIR}"
run_hooks image "${OSTREE_DEPLOYMENT}"
"${EIB_HELPERSDIR}"/kill-chroot-procs "${OSTREE_DEPLOYMENT}"
eib_umount_all

# Clear the cache and source mount variables in case they're used
# somewhere else
unset EIB_CACHEDIR_CHROOT EIB_SRCDIR_CHROOT

# Delete the resolv.conf copy so it's not shipped
rm -f "${OSTREE_DEPLOYMENT}"/etc/resolv.conf

create_image "$(eib_outfile img.${EIB_IMAGE_COMPRESSION})"
