#!/bin/bash -ex
# -*- mode: Shell-script; sh-basic-offset: 2; indent-tabs-mode: nil -*-
. "${EIB_BASELIB}"

# We do all fs preparation on the host disk, before then copying it into
# an image, in preparation for later development where the image will be sized
# dynamically based on how much data it includes.

mutable_deployment() {
  if [ -n "${OSTREE_DEPLOYMENT}" ]; then
    chattr -i "${OSTREE_DEPLOYMENT}"
  fi
}

kill_procs() {
  if [ -n "${OSTREE_DEPLOYMENT}" ]; then
    "${EIB_HELPERSDIR}"/kill-chroot-procs "${OSTREE_DEPLOYMENT}"
  fi
}

cleanup_devices() {
  if [ -n "${img_loop}" ]; then
    partx -v -d "${img_loop}"
    eib_delete_loop "${img_loop}"
  fi
  unset img_loop
}

cleanup() {
  mutable_deployment || :
  kill_procs || :
  eib_umount_all || :
  cleanup_devices || :
}
trap cleanup EXIT

recreate_dir "${EIB_OSTREE_CHECKOUT}"
REPOPATH=${EIB_OSTREE_CHECKOUT}/ostree/repo
REPO_EXTENSIONS="${REPOPATH}"/extensions/eos
BOOT=${EIB_OSTREE_CHECKOUT}/boot

ostree admin init-fs "${EIB_OSTREE_CHECKOUT}"
ostree admin --sysroot="${EIB_OSTREE_CHECKOUT}" os-init ${EIB_OSTREE_OS}
ostree --repo="${REPOPATH}" remote add ${EIB_OSTREE_REMOTE} \
  ${EIB_OSTREE_URL} ${EIB_OSTREE_BRANCH_DEPLOY}
ostree --repo="${REPOPATH}" pull-local --disable-fsync \
  --remote=${EIB_OSTREE_REMOTE} ${EIB_OSTREE_REPODIR} ${EIB_OSTREE_BRANCH_DEPLOY}

# Basic bootloader setup
if [[ "${EIB_ARCH}" == "armhf" ]]; then
  mkdir -p "${BOOT}"/loader.0
  ln -s loader.0 "${BOOT}"/loader
  # Empty uEnv.txt otherwise ostree gets upset
  > "${BOOT}"/loader/uEnv.txt
  ln -s loader/uEnv.txt "${BOOT}"/uEnv.txt
else
  # Assume grub for all other architectures
  mkdir -p "${BOOT}"/grub
fi

kargs=(--karg=rw --karg=splash \
    --karg=plymouth.ignore-serial-consoles --karg=quiet)
ostree admin --sysroot="${EIB_OSTREE_CHECKOUT}" deploy \
  --os=${EIB_OSTREE_OS} "${kargs[@]}" \
  ${EIB_OSTREE_REMOTE}:${EIB_OSTREE_BRANCH_DEPLOY}

# Copy the summary file into the repository in the deployment, so it can be
# served by eos-update-server to other computers, as soon as the image is
# booted.
mkdir -p "${REPO_EXTENSIONS}"
cp "${EIB_OSTREE_REPODIR}/tmp/cache/summaries/${EIB_OSTREE_REMOTE}" \
   "${REPO_EXTENSIONS}"/eos-summary
cp "${EIB_OSTREE_REPODIR}/tmp/cache/summaries/${EIB_OSTREE_REMOTE}.sig" \
   "${REPO_EXTENSIONS}"/eos-summary.sig

# There's no current symlink anymore, so query the deployment status.
# This will be the second parameter on the first line.
export OSTREE_CURRENT_DEPLOYMENT=$(ostree admin \
  --sysroot="${EIB_OSTREE_CHECKOUT}" status | awk '{print $2; exit}')
export OSTREE_DEPLOYMENT="${EIB_OSTREE_CHECKOUT}"/ostree/deploy/${EIB_OSTREE_OS}/deploy/${OSTREE_CURRENT_DEPLOYMENT}
export OSTREE_VAR="${EIB_OSTREE_CHECKOUT}"/ostree/deploy/${EIB_OSTREE_OS}/var

treeinfo="${EIB_TMPDIR}"/ostree.txt
echo "Branch ${EIB_OSTREE_BRANCH}" > ${treeinfo}
ostree --repo="${EIB_OSTREE_CHECKOUT}"/ostree/repo show \
  ${EIB_OSTREE_BRANCH_DEPLOY} >> ${treeinfo}

# Output package list using the dpkg database from the deployment's /var
dpkgdir="${OSTREE_DEPLOYMENT}"/var/lib/dpkg
packageinfo="${EIB_TMPDIR}"/packages.txt
dpkg-query -W --admindir="${dpkgdir}" > "${packageinfo}"

# Add package info to manifest using helper. This needs to be run here
# rather than in an image hook because the dpkg database will be masked
# by the OS /var mount.
pkg_manifest="${EIB_MANIFESTDIR}"/packages.json
"${EIB_HELPERSDIR}"/packages-manifest > "${pkg_manifest}"

run_hooks content "${OSTREE_DEPLOYMENT}"

create_image() {
  local outfile=$1

  # Create images according to data size, with 1GB free space.
  local img_size=$(du --block-size=1 -s "${EIB_OSTREE_CHECKOUT}")
  img_size=${img_size%$'\t'*}
  (( img_size += 1024 * 1024 * 1024 ))
  echo "Creating $1 image with size ${img_size}"

  local img="${EIB_TMPDIR}/${EIB_OUTVERSION}.img"
  rm -f "${img}"
  truncate -s ${img_size} "${img}"

  (
    # Empty space up to 1mb (for GPT, and for uboot on ARM)
    echo -n "start=2048, "

    case "${EIB_ARCH}" in
      i386|amd64)
        # EFI system partition
        echo "size=62MiB, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
        # GRUB BIOS BOOT partition
        echo "size=1MiB, type=21686148-6449-6E6F-744E-656564454649"
        ;;
    esac

    if [ "${EIB_IMAGE_PARTITION_TABLE}" == "dos" ]; then
      part_type="83"
    else
      # Partition Type GUIDs
      # https://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec/
      case "${EIB_ARCH}" in
        i386|amd64)
          # Root Partition (x86-64)
          part_type="4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709"
          ;;
        armhf)
          # Root Partition (32-bit ARM)
          part_type="69DAD710-2CE4-4E3C-B16C-21A1D49ABED3"
          ;;
        *)
          echo "Unrecognized architecture ${EIB_ARCH}" >&2
          return 1
          ;;
      esac
    fi

    if [[ "${EIB_IMAGE_ROOTFS_RESIZE}" == "true" ]]; then
      # Remaining space is root fs, with special the special 55 attr as a
      # marker indicating the partition should be resized later
      # attrs=... is unused for DOS partition table so it's safe to leave it here
      echo "type=${part_type}, attrs=GUID:55"
    else
      echo "type=${part_type}"
    fi
  ) | sfdisk --force --label "${EIB_IMAGE_PARTITION_TABLE}" "${img}"

  if [ "${EIB_IMAGE_PARTITION_TABLE}" == "dos" ] && [ "${EIB_IMAGE_ROOTFS_RESIZE}" == "true" ]; then
    # With the latest 'sfdisk' we are not allowed anymore to create a 0B partition
    # Bypass this limitation directly hacking into the MBR to set the marker
    printf "\xdd" | dd of=${img} bs=1 count=1 seek=498 conv=notrunc
  fi

  img_loop=$(losetup -f --show "${img}")
  eib_partx_scan "${img_loop}"

  case "${EIB_ARCH}" in
    i386|amd64)
      esp_loop=${img_loop}p1
      bios_boot_loop=${img_loop}p2
      root_loop=${img_loop}p3
      mkfs.vfat "${esp_loop}"
      ;;
    *)
      root_loop=${img_loop}p1
      ;;
  esac

  mke2fs -t ext4 -O dir_index,^huge_file -m1 -L ostree ${root_loop}
  ROOT="${EIB_TMPDIR}"/mnt
  DEPLOY="${ROOT}"/ostree/deploy/${EIB_OSTREE_OS}/deploy/${OSTREE_CURRENT_DEPLOYMENT}
  mkdir -p "${ROOT}"
  eib_mount ${root_loop} "${ROOT}"
  eib_write_version_xattr "${ROOT}"

  case "${EIB_ARCH}" in
    i386|amd64)
      ESP="${ROOT}"/boot/efi
      mkdir -p "${ESP}"
      eib_mount ${esp_loop} "${ESP}"
      ;;
  esac

  # Copy contents into image, preserving attributes, timestamps, hardlinks, etc.
  cp -a "${EIB_OSTREE_CHECKOUT}"/* "${ROOT}"

  # Make the deployment root mutable and delete the checkout since it's
  # no longer needed after this. Unset checkout derived variables so we
  # don't try to operate on them later (e.g., making a non-existent
  # OSTREE_DEPLOYMENT mutable at exit).
  mutable_deployment
  rm -rf "${EIB_OSTREE_CHECKOUT}"
  unset OSTREE_DEPLOYMENT OSTREE_VAR

  # Begin the images manifest frament
  img_manifest="${EIB_MANIFESTDIR}"/images
  cat > "${img_manifest}" <<EOF
{
  "images": {
EOF

  # Install bootloader
  case "${EIB_ARCH}" in
    armhf)
      case "${EIB_PLATFORM}" in
        odroidu2)
          # from hardkernel u-boot sd_fusing.sh
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/exynos4_odroid
          dd conv=notrunc if="${UBOOT_PATH}"/bl1.HardKernel of=${img} seek=1
          dd conv=notrunc if="${UBOOT_PATH}"/bl2.HardKernel of=${img} seek=31
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} seek=63
          dd conv=notrunc if="${UBOOT_PATH}"/tzsw.HardKernel of=${img} seek=2111
          ;;
        sqwerty)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/exynos4_sqwerty
          dd conv=notrunc if="${UBOOT_PATH}"/bl1.Sqwerty of=${img} seek=1
          dd conv=notrunc if="${UBOOT_PATH}"/bl2.Sqwerty of=${img} seek=31
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} seek=63
          dd conv=notrunc if="${UBOOT_PATH}"/tzsw.Sqwerty of=${img} seek=2111
          ;;
        ec100)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/meson8b_m201
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} bs=1 count=442
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin of=${img} bs=17408 skip=1 seek=1
          ;;
        s905x)
          local UBOOT_PATH="${DEPLOY}"/usr/lib/u-boot/s905x
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin.padded of=${img} bs=1 count=442
          dd conv=notrunc if="${UBOOT_PATH}"/u-boot.bin.padded of=${img} bs=512 skip=1 seek=1
          ;;
        *)
          echo "Unrecognized armhf platform ${EIB_ARCH}" >&2
          return 1
          ;;
      esac
      ;;
    i386|amd64)
      # MBR bootloader install
      > "${DEPLOY}"/img
      mount --bind "${img}" "${DEPLOY}"/img
      mount --bind "${ROOT}"/boot "${DEPLOY}"/boot
      mount --bind /dev "${DEPLOY}"/dev
      mount --bind /proc "${DEPLOY}"/proc
      mount --bind /sys "${DEPLOY}"/sys

      # Install the real MBR bootloader
      chroot "${DEPLOY}" /usr/sbin/grub-install \
                   --modules="ext2 part_msdos part_gpt search" \
                   --directory=/usr/lib/grub/i386-pc \
                   --config=/usr/lib/grub/conf/grub_embedded_bios.cfg \
                   /img

      # Copy grub.cfg
      cp "${DEPLOY}/usr/lib/grub/conf/grub.cfg" "${DEPLOY}/boot/grub/grub.cfg"

      if [ "$EIB_IMAGE_BOOT_ZIP" == "true" ]; then
        local boot_zip_dir=${EIB_TMPDIR}/boot_zip
        mkdir "${boot_zip_dir}"

        # Generate GRUB standalone images and eosldr
        "${EIB_HELPERSDIR}"/create-grub-images "${DEPLOY}" "${boot_zip_dir}"

        # Capture second-stage config and modules
        cp -a "${DEPLOY}/boot/grub" "${boot_zip_dir}"
      fi

      umount "${DEPLOY}"/{boot,dev,img,proc,sys}
      rm -f "${DEPLOY}"/img

      # UEFI bootloader install
      cp -r "${DEPLOY}"/boot/efi/EFI "${ESP}"

      if [ "$EIB_IMAGE_BOOT_ZIP" == "true" ]; then
        # Capture EFI GRUB for both live+installer and dual-boot image boots.
        #
        # From 3.1.x onwards, our ESP has the following layout:
        #
        # EFI/
        #   endless/
        #     grubx64.efi
        #     shim.efi
        #     BOOT.CSV
        #     MokManager.efi
        #   BOOT/
        #     bootx64.efi  - identical to shim.efi
        #     fallback.efi
        #
        # However, the installer for Windows expects the following, older
        # layout in boot.zip:
        #
        # EFI/
        #   BOOT/
        #     bootx64.efi
        #     grubx64.efi
        #     MokManager.efi
        #
        # It copies the entire contents of EFI/BOOT to EFI/Endless on the ESP,
        # and creates a boot entry for EFI/Endless/bootx64.efi. For backwards-
        # compatibility, we need to replicate this:
        mkdir -p "${boot_zip_dir}/EFI/BOOT"
        cp \
          "${DEPLOY}"/boot/efi/EFI/BOOT/bootx64.efi \
          "${DEPLOY}"/boot/efi/EFI/endless/MokManager.efi \
          "${DEPLOY}"/boot/efi/EFI/endless/grubx64.efi \
          "${boot_zip_dir}/EFI/BOOT"

        # For forwards-compatibility with a future release of the installer, we
        # capture the new layout (in particular, including fallback.efi):
        mkdir -p "${boot_zip_dir}/EFI2"
        cp -r "${DEPLOY}"/boot/efi/EFI/* "${boot_zip_dir}/EFI2"

        # Bundle all GRUB versions up for distribution
        local boot_zip="$(eib_outfile boot.zip)"
        (cd "${boot_zip_dir}" && zip "${boot_zip}" -r *)
        rm -r "${boot_zip_dir}"
        sign_file "${boot_zip}" &

        # Generate manifest information
        local boot_zip_name=$(basename "${boot_zip}")
        local boot_zip_size=$(stat -c "%s" "${boot_zip}")
        local boot_zip_signature="${boot_zip_name}.asc"
        cat >> "${img_manifest}" <<EOF
    "boot": {
      "file": "${boot_zip_name}",
      "compressed_size": ${boot_zip_size},
      "compression_type": "zip",
      "signature": "${boot_zip_signature}"
    },
EOF
      else
        # No boot.zip means this is eosinstaller, not an installable image.
        # Since this will only be used on removable media, it should not
        # include fallback.efi, which alters the system's BootOrder. In effect,
        # we are recreating the layout in boot.zip/EFI, only on the real ESP.
        rm "${ESP}/EFI/BOOT/fallback.efi"
        mv \
          "${ESP}/EFI/endless/MokManager.efi" \
          "${ESP}/EFI/endless/grubx64.efi" \
          "${ESP}/EFI/BOOT/"
        rm -r "${ESP}/EFI/endless"
      fi
      ;;
    *)
      echo "Unrecognized architecture ${EIB_ARCH}" >&2
      return 1
      ;;
  esac

  eib_fix_boot_checksum "${img_loop}" "${DEPLOY}"

  # Read OS version from ostree deployment before we unmount it
  local version=$(. ${DEPLOY}/etc/os-release && echo ${VERSION})

  # Restore the immutable attribute on the deployment root lost via cp
  chattr +i "${DEPLOY}"

  # Cleanup mounts and devices
  eib_umount_all
  cleanup_devices

  # Sign uncompressed image (used when installing from a live image)
  local img_asc="$(eib_outfile img.asc)"
  sign_file "${img}" "${img_asc}" &

  # Publish uncompressed file size.
  local img_extracted_size=$(stat -c "%s" "${img}")
  echo "${img_extracted_size}" > "${outfile}.size"

  # Compress image file.
  eib_compress_image "${img}" "${outfile}"

  # Sign compressed image (used to verify download)
  sign_file ${outfile} &

  # Copy ostree, package and config info to per-personality outdir.
  cp "${EIB_TMPDIR}"/ostree.txt "$(eib_outfile ostree.txt)"
  cp "${EIB_TMPDIR}"/packages.txt "$(eib_outfile packages.txt)"
  cp "${EIB_TMPDIR}"/config.ini "$(eib_outfile config.ini)"

  # Create split image for 2 disk systems if required.
  if [ "${EIB_IMAGE_SPLIT}" = true ]; then
    "${EIB_HELPERSDIR}"/split-image "${img}"
  fi

  # Await sign_file subprocesses
  wait

  # Create ISO if required. This requires the uncompressed image, its
  # signature, and the signature for boot.zip. In theory we could `wait` only
  # for those two signatures and allow compressing the image and signing it to
  # happen in parallel with creating the ISO.
  if [ "${EIB_IMAGE_ISO}" == true ]; then
    "${EIB_HELPERSDIR}"/create-iso "${version}" "$(eib_outfile iso)" \
      "${img}" "${img_asc}" "${boot_zip}" "${boot_zip}.asc"
  fi

  # Remove uncompressed image, if not already deleted by helpers/create-iso
  rm -f "${img}"

  # Finish image manifest info
  local img_name=$(basename "${outfile}")
  local img_compressed_size=$(stat -c "%s" "${outfile}")
  local img_signature="${img_name}.asc"
  cat >> "${img_manifest}" <<EOF
    "full": {
      "file": "${img_name}",
      "extracted_size": ${img_extracted_size},
      "compressed_size": ${img_compressed_size},
      "compression_type": "${EIB_IMAGE_COMPRESSION}",
      "signature": "${img_signature}"
    }
  }
}
EOF
}

echo "Create image for personality ${EIB_PERSONALITY}"

# Mount the deployment directory over itself so / is a real mount in the
# chroot. This is needed for bubblewrap, which wants to mark the / mount
# as a slave.
eib_mount --bind "${OSTREE_DEPLOYMENT}" "${OSTREE_DEPLOYMENT}"

# Mark the hook root mount private. This has 2 benefits:
#
# 1. Any mounts placed under it will not leak out to the parent mount.
#    That keeps aliased mounts from showing up elsewhere in the system.
#
# 2. Bubblewrap uses pivot_root, which requires that the old root is not
#    a shared mount.
mount --make-private "${OSTREE_DEPLOYMENT}"

# Finally, pivot_root also requires that the parent of the old root is
# not a shared mount. Bind mount the hook root over itself again so the
# parent is the above private mount.
#
# See https://github.com/projectatomic/bubblewrap/issues/135.
eib_mount --bind "${OSTREE_DEPLOYMENT}" "${OSTREE_DEPLOYMENT}"

# Mount kernel filesystems into deployment for image hooks
eib_mount -t sysfs sysfs "${OSTREE_DEPLOYMENT}"/sys
eib_mount -t proc proc "${OSTREE_DEPLOYMENT}"/proc
eib_mount --bind /dev "${OSTREE_DEPLOYMENT}"/dev
eib_mount --bind /dev/pts "${OSTREE_DEPLOYMENT}"/dev/pts

# Mount a tmpfs at /tmp so that hooks can use it without persisting to
# the image
eib_mount -t tmpfs tmpfs "${OSTREE_DEPLOYMENT}"/tmp

# Bind mount OS /var over deployment's /var for image hooks
eib_mount --bind "${OSTREE_VAR}" "${OSTREE_DEPLOYMENT}"/var

# Bind mount the checkout over deployment's /sysroot, so the ostree repo
# is available for image hooks
eib_mount --bind "${EIB_OSTREE_CHECKOUT}" "${OSTREE_DEPLOYMENT}"/sysroot

# Bind mount the content directory into the deployment so chroot hooks
# can access it
export EIB_CONTENTDIR_CHROOT=/tmp/content
mkdir -p "${OSTREE_DEPLOYMENT}${EIB_CONTENTDIR_CHROOT}"
eib_mount --bind "${EIB_CONTENTDIR}" \
          "${OSTREE_DEPLOYMENT}${EIB_CONTENTDIR_CHROOT}"

# Copy in the host's /etc/resolv.conf so the one from the ostree (if it
# exists) is not used and DNS can be resolved.
cp -f /etc/resolv.conf "${OSTREE_DEPLOYMENT}"/etc/resolv.conf

# /usr/local is a symlink to /var/local in the ostree, but /var/local
# doesn't exist yet since it's created from systemd-tmpfiles at runtime.
# Create it now so that hooks can populate /usr/local.
if [ -L "${OSTREE_DEPLOYMENT}"/usr/local ]; then
  usr_local_link=$(readlink "${OSTREE_DEPLOYMENT}"/usr/local)
  if [ "${usr_local_link::1}" = / ]; then
    # Absolute path, prepend the deployment root
    usr_local_target="${OSTREE_DEPLOYMENT}${usr_local_link}"
  else
    # Relative path, prepend the deployment's /usr
    usr_local_target="${OSTREE_DEPLOYMENT}/usr/${usr_local_link}"
  fi

  mkdir -p "${usr_local_target}"
fi

recreate_dir "${EIB_OUTDIR}"
run_hooks image "${OSTREE_DEPLOYMENT}"
"${EIB_HELPERSDIR}"/kill-chroot-procs "${OSTREE_DEPLOYMENT}"
eib_umount_all

# Clear the content mount variable in case it's used somewhere else
unset EIB_CONTENTDIR_CHROOT

# Delete the resolv.conf copy so it's not shipped
rm -f "${OSTREE_DEPLOYMENT}"/etc/resolv.conf

create_image "$(eib_outfile img.${EIB_IMAGE_COMPRESSION})"
