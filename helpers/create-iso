#!/bin/bash -ex
# -*- mode: Shell-script; sh-basic-offset: 2; indent-tabs-mode: nil -*-
. "${EIB_BASELIB}"

# Write a bootable ISO image containing the image file, Windows tool and other
# files needed to install Endless OS in every supported configuration.
create_iso() {
  local version=${1:?No OS version for $FUNCNAME}
  shift
  local iso=${1:?No target filename $FUNCNAME}
  shift
  local img=${1:?No image supplied to $FUNCNAME}
  shift

  # Symlink img.asc, boot.zip, boot.zip.asc into the same directory as $img
  for i in "$@"; do
    ln -s $i "${EIB_TMPDIR}/$(basename $i)"
  done

  # Trim duplication of product name from personality name (eg fnde_aluno)
  personality=${EIB_PERSONALITY#${EIB_PRODUCT}_}

  # Set label for ISO - including the personality name "bare" is not ideal
  # but generally speaking we are limited to 32 characters, and the image
  # builder is unaware of localised personality names
  label="${EIB_IMAGE_PRODUCT_NAME} ${version} ${personality}"

  # Download from a non-standard URL to allow us to QA the installer for
  # the branch we're building, ahead of the main release.
  # TODO: Perhaps we should create a package in OBS which just contains
  # endless-installer.exe?
  local ei_url="https://d1anzknqnc1kmb.cloudfront.net/endless-installer/endless-installer-${EIB_BRANCH}.exe"
  local ei_exe="${EIB_TMPDIR}/endless-installer.exe"
  wget -O "${ei_exe}" "${ei_url}"

  # Publish size of image inside the ISO (& squashfs). This is the interesting
  # number that can't be easily determined from the size of the ISO itself.
  # eos-write-live-image will delete $img after creating the squashfs to reduce
  # peak disk usage, so we need to determine its size beforehand.
  local img_size=$(stat -c "%s" "${img}")
  echo "${img_size}" > "${iso}.size"

  local squashfs_comp=gzip
  if [ "${EIB_IMAGE_COMPRESSION}" == "xz" ]; then
    squashfs_comp=xz
  fi

  TMPDIR="${EIB_TMPDIR}" eos-write-live-image --debug \
    --iso \
    --os-image "${img}" \
    --windows-tool "${ei_exe}" \
    --delete-os-image \
    --force \
    --label "${label}" \
    --squashfs-comp "${squashfs_comp}" \
    "${iso}"

  # Sign ISO
  sign_file "${iso}"

  # Generate ISO manifest information
  local iso_name=$(basename "${iso}")
  local iso_compressed_size=$(stat -c "%s" "${iso}")
  local iso_signature=$(basename "${iso}.asc")

  cat > "${EIB_MANIFESTDIR}"/iso.json <<EOF
{
  "images": {
    "iso": {
      "file": "${iso_name}",
      "extracted_size": ${img_size},
      "compressed_size": ${iso_compressed_size},
      "compression_type": "iso+squashfs",
      "signature": "${iso_signature}"
    }
  }
}
EOF
}

# Run main function for this image.
create_iso "$@"
