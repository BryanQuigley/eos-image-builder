#!/bin/bash -ex
. "${EOB_BASELIB}"

# Split the existing full image into two files. One image file is for
# the main disk, and one is for a supplemental disk to be filled with
# apps.

cleanup_mounts() {
  [ -n "${EXTRA}" ] && umount "${EXTRA}" || :
  [ -n "${OSTREE_CURRENT_VAR}" ] && umount "${OSTREE_CURRENT_VAR}" || :
  [ -n "${ROOT}" ] && umount "${ROOT}" || :
  unset EXTRA OSTREE_CURRENT OSTREE_CURRENT_VAR ROOT
}

cleanup_devices() {
  cleanup_mounts
  [ -n "${ROOT_LOOP}" ] && losetup -d "${ROOT_LOOP}" || :
  [ -n "${EXTRA_LOOP}" ] && losetup -d "${EXTRA_LOOP}" || :
  unset ROOT_LOOP EXTRA_LOOP EXTRA_MOUNT PERSONALITY
}

cleanup() {
  cleanup_mounts
  cleanup_devices
}
trap cleanup EXIT

# Shrink the disk1 image after migration to extra storage.
shrink_disk1_image() {
  local disk1_img=$1
  local personality=${2:-no personality}

  # Calculate the shrunken root fs size from the esimated minimum. The
  # minimum size is in blocks, which are assumed to be 4kB.
  local root_part_min_blocks=$(resize2fs -P $ROOT_LOOP | \
    awk '/^Estimated minimum size/{print $NF}')
  local root_part_size=$((root_part_min_blocks * 4096))

  # Calculate the total disk1 size. Add the sectors up to the end of the
  # boot partition and the just recalculated root partition size.
  local disk1_img_size=$((EOB_DISK1_PART2_START * 512 + root_part_size))

  # After booting, the root fs will be expanded to fill any available
  # space, and we want to provide 1 GiB of free space on the device. The
  # actual "16 GB" eMMC device on Intel Sqwerty was 15758000128 bytes,
  # but we'll assume 98% available space, which is 15680000000 bytes.
  # Fail if the image won't fit in this space.
  local disk1_max_img_size=$(python -c "print int(16 * 10**9 * 0.98)")
  ((disk1_max_img_size -= 1 * 2**30))
  if ((disk1_img_size > disk1_max_img_size)); then
    echo "ERROR: ${personality} disk1 image exceeds ${disk1_max_img_size}" >&2
    return 1
  fi

  # So we don't perform the initial boot with a totally full root, add
  # 100MB of initial free space.
  ((root_part_size += 100 * 2**20))
  ((disk1_img_size += 100 * 2**20))
  echo "Creating ${personality} disk1 image with size ${disk1_img_size}"

  # Resize the root fs, specifying sectors from bytes.
  local root_part_len=$((root_part_size / 512))
  e2fsck -f -p "${ROOT_LOOP}"
  resize2fs "${ROOT_LOOP}" "${root_part_len}s"

  # Resize the image file and rewrite the partition table. The image
  # file is truncated first to try to catch errors in the partition
  # setup.
  truncate -s ${disk1_img_size} "${disk1_img}"
  sfdisk -S 32 -H 32 --force -uS "${disk1_img}" <<EOF
${EOB_DISK1_PART1_START},${EOB_DISK1_PART1_LEN},,*
${EOB_DISK1_PART2_START},${root_part_len},,
EOF

  # Ensure magic marker on 4th partition still exists.
  sfdisk --change-id "${disk1_img}" 4 dd
}

# Shrink the disk2 image after migration to extra storage.
shrink_disk2_image() {
  local disk2_img=$1
  local personality=${2:-no personality}

  # Calculate the shrunken extra fs size from the esimated minimum. The
  # minimum size is in blocks, which are assumed to be 4kB.
  local extra_part_min_blocks=$(resize2fs -P $EXTRA_LOOP | \
    awk '/^Estimated minimum size/{print $NF}')
  local extra_part_size=$((extra_part_min_blocks * 4096))

  # Calculate the total disk2 size. Add any additional sectors before
  # the first partition.
  local disk2_img_size=$((extra_part_size + EOB_DISK2_PART1_START * 512))
  echo "Creating ${personality} disk2 image with size ${disk2_img_size}"

  # Resize the extra fs, specifying sectors from bytes.
  local extra_part_len=$((extra_part_size / 512))
  e2fsck -f -p "${EXTRA_LOOP}"
  resize2fs "${EXTRA_LOOP}" "${extra_part_len}s"

  # Resize the image file and rewrite the partition table. The image
  # file is truncated first to try to catch errors in the partition
  # setup.
  truncate -s ${disk2_img_size} "${disk2_img}"
  sfdisk -S 32 -H 32 --force -uS "${disk2_img}" <<EOF
${EOB_DISK2_PART1_START}
EOF

  # Add magic marker on 4th partition to signal resizing is wanted.
  sfdisk --change-id "${disk2_img}" 4 dd
}

split_image() {
  local personality=$1
  local disk1_img=${EOB_SCRATCH}/disk1
  local disk2_img=${EOB_SCRATCH}/disk2

  local full_img_gz disk1_img_gz disk2_img_gz
  if [ -n "$personality" ]; then
    full_img_gz=$(eob_outfile ${personality}.img.gz)
    disk1_img_gz=$(eob_outfile ${personality}-disk1.img.gz)
    disk2_img_gz=$(eob_outfile ${personality}-disk2.img.gz)
  else
    full_img_gz=$(eob_outfile img.gz)
    disk1_img_gz=$(eob_outfile disk1.img.gz)
    disk2_img_gz=$(eob_outfile disk2.img.gz)
  fi

  # Uncompress full image as the base for disk1.
  rm -f "${disk1_img}"
  pigz -dc "${full_img_gz}" > "${disk1_img}"

  # Mount root filesystem from the 2nd partition of the image file.
  ROOT_LOOP=$(losetup --show --offset $((EOB_DISK1_PART2_START * 512)) \
    -f "${disk1_img}")
  ROOT=${EOB_SCRATCH}/mnt
  recreate_dir "${ROOT}"
  mount -t ext4 "${ROOT_LOOP}" "${ROOT}"

  # Bind mount the ostree /var into the current deployment so it
  # resembles the booted system.
  export OSTREE_CURRENT="${ROOT}"/ostree/deploy/${EOB_PRODUCT}/current
  local ostree_var="${ROOT}"/ostree/deploy/${EOB_PRODUCT}/var
  OSTREE_CURRENT_VAR="${OSTREE_CURRENT}"/var
  mount --bind "${ostree_var}" "${OSTREE_CURRENT_VAR}"

  # Create disk2 image file with 1 partition for our "8 GB" SD card. The
  # actual size of 2 devices in bytes is 7948206080. Since that might
  # vary and we want to be a little conservative, use 98% of 8 GB, which
  # is 7840000000 bytes.
  rm -f "${disk2_img}"
  local disk2_img_size=$(python -c "print int(8 * 10**9 * 0.98)")
  truncate -s ${disk2_img_size} "${disk2_img}"
  sfdisk -S 32 -H 32 --force -uS "${disk2_img}" <<EOF
${EOB_DISK2_PART1_START}
EOF

  # Create disk2 filesystem and mount it on top of the above bind mount.
  EXTRA_LOOP=$(losetup --show --offset $((EOB_DISK2_PART1_START * 512)) \
    -f "${disk2_img}")
  mke2fs -t ext4 -O dir_index,^huge_file -m1 -L extra "${EXTRA_LOOP}"
  EXTRA="${OSTREE_CURRENT_VAR}"/endless-extra
  recreate_dir "${EXTRA}"
  mount -t ext4 "${EXTRA_LOOP}" "${EXTRA}"

  # Split files from the root filesystem into extra. Let the hooks know
  # where the extra filesystem is mounted and what the personality is.
  export EXTRA_MOUNT=/var/endless-extra
  export PERSONALITY=${personality}
  run_hooks split "${OSTREE_CURRENT}"

  # Enable /endless overlayfs mount unit for the split image.
  mkdir -p "${OSTREE_CURRENT}"/etc/systemd/system/local-fs.target.requires
  ln -sf /lib/systemd/system/endless.mount \
    "${OSTREE_CURRENT}"/etc/systemd/system/local-fs.target.requires/

  # Unmount the filesystems and shrink the image files.
  cleanup_mounts
  shrink_disk1_image "${disk1_img}" "${personality}"
  shrink_disk2_image "${disk2_img}" "${personality}"

  # Delete loop devices and cleanup variables for the next iteration.
  cleanup_devices

  # gzip image files and remove uncompressed versions.
  pigz --no-name -c "${disk1_img}" > "${disk1_img_gz}"
  rm -f "${disk1_img}"
  pigz --no-name -c "${disk2_img}" > "${disk2_img_gz}"
  rm -f "${disk2_img}"

  # Create signatures.
  sign_file "${disk1_img_gz}" &
  sign_file "${disk2_img_gz}" &
  wait
}

# Run main function for this personality.
split_image "$1"
