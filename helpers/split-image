#!/bin/bash -ex
# -*- mode: Shell-script; sh-basic-offset: 2; indent-tabs-mode: nil -*-
. "${EIB_BASELIB}"

# Split the existing full image into two files. One image file is for
# the main disk, and one is for a supplemental disk to be filled with
# apps.

cleanup_loop() {
  partx -v -d "$1"
  eib_delete_loop "$1"
}

cleanup_devices() {
  [ -n "${DISK1_LOOP}" ] && cleanup_loop "${DISK1_LOOP}"
  [ -n "${DISK2_LOOP}" ] && cleanup_loop "${DISK2_LOOP}"
  unset DISK1_LOOP DISK2_LOOP
}

cleanup() {
  eib_umount_all || :
  cleanup_devices || :
}
trap cleanup EXIT

# Shrink the disk1 image after migration to extra storage.
shrink_disk1_image() {
  local disk1_img=$1
  local personality=${2:-no personality}

  # Calculate the shrunken root fs size from the esimated minimum. The
  # minimum size is in blocks, which are assumed to be 4kB.
  e2fsck -f -p "${ROOT_LOOP}"
  local root_part_min_blocks=$(resize2fs -P $ROOT_LOOP | \
    awk '/^Estimated minimum size/{print $NF}')
  local root_part_size=$((root_part_min_blocks * 4096))

  # Calculate the new total disk1 size
  local new_disk1_img_size=$root_part_size
  local old_disk1_img_size=$(blockdev --getsize64 $DISK1_LOOP)
  local old_disk1_root_size=$(blockdev --getsize64 $ROOT_LOOP)

  # Add the same number of sectors before and after the root partition
  (( new_disk1_img_size += old_disk1_img_size - old_disk1_root_size))

  # After booting, the root fs will be expanded to fill any available
  # space, and we want to provide 1 GiB of free space on the device. The
  # actual "16 GB" eMMC device on Intel Sqwerty was 15758000128 bytes,
  # but we'll assume 98% available space, which is 15680000000 bytes.
  # Fail if the image won't fit in this space.
  local disk1_max_img_size=$(python -c "print int(16 * 10**9 * 0.98)")
  ((disk1_max_img_size -= 1 * 2**30))
  if ((new_disk1_img_size > disk1_max_img_size)); then
    echo "ERROR: ${personality} disk1 image exceeds ${disk1_max_img_size}" >&2
    return 1
  fi

  # So we don't perform the initial boot with a totally full root, add
  # 100MB of initial free space.
  ((root_part_size += 100 * 2**20))
  ((new_disk1_img_size += 100 * 2**20))

  if ((new_disk1_img_size >= old_disk1_img_size)); then
    echo "Avoid growing ${personality} disk1 image to ${new_disk1_img_size}"
    return 0
  fi

  echo "Creating ${personality} disk1 image with size ${new_disk1_img_size}"

  # Resize the root fs, specifying sectors from bytes.
  local root_part_len=$((root_part_size / 512))
  e2fsck -f -p "${ROOT_LOOP}"
  resize2fs "${ROOT_LOOP}" "${root_part_len}s"

  # Read the current partition table. Must be done before truncating the
  # image; sfdisk doesn't manage to read the GPT from the truncated image
  # because it has lost the GPT backup.
  local orig_partitions=$(sfdisk -d "${disk1_img}")

  # Resize the image file first, to try to later catch errors in the partition
  # setup.
  truncate -s ${new_disk1_img_size} "${disk1_img}"

  # Adjust and restore the partition table
  # last-lba is removed for sfdisk to recompute
  # The final partition is sized according to our calculations
  echo "${orig_partitions}" | sed \
	-e '/^last-lba:/d' \
	-e "$ s/size=[0-9\t ]*,/size=${root_part_len},/" |
	sfdisk --force --label gpt "${disk1_img}"
}

# Shrink the disk2 image after migration to extra storage.
shrink_disk2_image() {
  local disk2_img=$1
  local personality=${2:-no personality}

  # Calculate the shrunken extra fs size from the esimated minimum. The
  # minimum size is in blocks, which are assumed to be 4kB.
  e2fsck -f -p "${EXTRA_LOOP}"
  local extra_part_min_blocks=$(resize2fs -P $EXTRA_LOOP | \
    awk '/^Estimated minimum size/{print $NF}')
  local extra_part_size=$((extra_part_min_blocks * 4096))

  # Calculate the new total disk1 size
  local new_disk2_img_size=$extra_part_size
  local old_disk2_img_size=$(blockdev --getsize64 $DISK2_LOOP)
  local old_disk2_extra_size=$(blockdev --getsize64 $EXTRA_LOOP)

  # Add the same number of sectors before and after the partition
  (( new_disk2_img_size += old_disk2_img_size - old_disk2_extra_size))

  echo "Creating ${personality} disk2 image with size ${new_disk2_img_size}"

  # Resize the extra fs, specifying sectors from bytes.
  local extra_part_len=$((extra_part_size / 512))
  e2fsck -f -p "${EXTRA_LOOP}"
  resize2fs "${EXTRA_LOOP}" "${extra_part_len}s"

  # Read the current partition table. Must be done before truncating the
  # image; sfdisk doesn't manage to read the GPT from the truncated image
  # because it has lost the GPT backup.
  local orig_partitions=$(sfdisk -d "${disk2_img}")

  # Resize the image file first to try to catch errors in the partition
  # setup.
  truncate -s ${new_disk2_img_size} "${disk2_img}"

  # Adjust and restore the partition table
  # last-lba is removed for sfdisk to recompute
  # The final partition is sized according to our calculations
  echo "${orig_partitions}" | sed \
	-e '/^last-lba:/d' \
	-e "$ s/size=[0-9\t ]*,/size=${extra_part_len},/" |
	sfdisk --force --label gpt "${disk2_img}"
}

split_image() {
  local disk1_img=$1
  local personality=$2
  local disk2_img=${EIB_SCRATCH}/disk2

  local disk1_img_gz disk2_img_gz
  if [ -n "$personality" ]; then
    disk1_img_gz=$(eib_outfile ${personality}.disk1.img.gz)
    disk2_img_gz=$(eib_outfile ${personality}.disk2.img.gz)
  else
    disk1_img_gz=$(eib_outfile disk1.img.gz)
    disk2_img_gz=$(eib_outfile disk2.img.gz)
  fi

  # Mount root filesystem from the last partition of the image file.
  DISK1_LOOP=$(losetup --show -f "${disk1_img}")
  eib_partx_scan "${DISK1_LOOP}"
  local disk1_parts=( "${DISK1_LOOP}"p* )
  ROOT_LOOP="${disk1_parts[-1]}"
  ROOT=${EIB_SCRATCH}/mnt
  recreate_dir "${ROOT}"
  eib_mount -t ext4 "${ROOT_LOOP}" "${ROOT}"

  # Bind mount the ostree /var into the current deployment so it
  # resembles the booted system.
  export OSTREE_CURRENT="${ROOT}"/ostree/deploy/${EIB_OSTREE_OS}/deploy/${OSTREE_CURRENT_DEPLOYMENT}
  local ostree_var="${ROOT}"/ostree/deploy/${EIB_OSTREE_OS}/var
  OSTREE_CURRENT_VAR="${OSTREE_CURRENT}"/var
  eib_mount --bind "${ostree_var}" "${OSTREE_CURRENT_VAR}"

  # Create disk2 image file with 1 partition for our "16 GB" SD card.
  # The actual size might vary and we want to be a little connservative,
  # so use 98% of 16 GB, which is 15680000000 bytes.
  rm -f "${disk2_img}"
  local disk2_img_size=$(python -c "print int(16 * 10**9 * 0.98)")
  truncate -s ${disk2_img_size} "${disk2_img}"

  # Attr 55 indicates that the partition should be resized later.
  echo "start=2048, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4, attrs=GUID:55" | sfdisk --force --label gpt "${disk2_img}"

  # Create disk2 filesystem and mount it on top of the above bind mount.
  DISK2_LOOP=$(losetup --show -f "${disk2_img}")
  eib_partx_scan "${DISK2_LOOP}"
  EXTRA_LOOP="${DISK2_LOOP}p1"
  mke2fs -t ext4 -O dir_index,^huge_file -m1 -L extra "${EXTRA_LOOP}"
  EXTRA="${OSTREE_CURRENT_VAR}"/endless-extra
  recreate_dir "${EXTRA}"
  eib_mount -t ext4 "${EXTRA_LOOP}" "${EXTRA}"
  eib_write_version_xattr "${EXTRA}" ${personality}

  # Split files from the root filesystem into extra. Let the hooks know
  # where the extra filesystem is mounted and what the personality is.
  export EXTRA_MOUNT=/var/endless-extra
  export EIB_PERSONALITY=${personality}

  # Mount kernel filesystems into deployment for split hooks
  eib_mount -t sysfs sysfs "${OSTREE_CURRENT}"/sys
  eib_mount -t proc proc "${OSTREE_CURRENT}"/proc
  eib_mount --bind /dev "${OSTREE_CURRENT}"/dev

  run_hooks split "${OSTREE_CURRENT}"

  # Enable /var/endless-extra mount unit for the split image.
  mkdir -p "${OSTREE_CURRENT}"/etc/systemd/system/local-fs.target.wants
  ln -sf "/lib/systemd/system/var-endless\x2dextra.mount" \
    "${OSTREE_CURRENT}"/etc/systemd/system/local-fs.target.wants/

  # Unmount the filesystems and shrink the image files.
  eib_umount_all
  shrink_disk1_image "${disk1_img}" "${personality}"
  shrink_disk2_image "${disk2_img}" "${personality}"

  # Temporarily remount the filesystem to fix the disk1 checksum using
  # the installed tool.
  eib_mount -t ext4 "${ROOT_LOOP}" "${ROOT}"
  eib_fix_boot_checksum "${DISK1_LOOP}" "${OSTREE_CURRENT}"
  eib_umount_all

  # Delete loop devices and cleanup variables for the next iteration.
  cleanup_devices

  # gzip image files and remove uncompressed versions.
  pigz --no-name -c "${disk1_img}" > "${disk1_img_gz}"
  rm -f "${disk1_img}"
  pigz --no-name -c "${disk2_img}" > "${disk2_img_gz}"
  rm -f "${disk2_img}"

  # Create signatures.
  sign_file "${disk1_img_gz}" &
  sign_file "${disk2_img_gz}" &
  wait
}

# Run main function for this image and personality.
split_image "$@"
