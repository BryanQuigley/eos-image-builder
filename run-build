#!/usr/bin/python3
# -*- mode: Python; coding: utf-8 -*-

# Endless image builder
#
# Copyright (C) 2014-2015  Endless Mobile, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from argparse import ArgumentParser
import datetime
import fnmatch
import os
import shutil
import subprocess
import sys

SRCDIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(1, os.path.join(SRCDIR, 'lib'))
import eib

class ImageBuilder(object):
    # Attributes to be exported to environment
    ENV_ATTRS = ['product', 'branch', 'platform', 'personality',
                 'force', 'dry_run', 'sysconf', 'build_version', 'arch',
                 'split_images', 'obs_repo', 'image_signing_keyid',
                 'ostree_branch', 'ostree_repo', 'ostree_os',
                 'ostree_checkout', 'ostree', 'ostree_branch_deploy',
                 'ostree_url', 'ostree_int_url', 'ostree_tmpdir',
                 'image_host_short', 'image_host', 'image_user',
                 'image_path', 'image_url_root', 'email_from',
                 'email_replyto', 'email_to', 'jenkins_url',
                 'jenkins_user', 'jenkins_token']

    SUPPORTED_ARCHES = ['i386', 'armhf']

    def __init__(self, product, branch, arch, platform, personality,
                 force=False, dry_run=False):
        self.product = product
        self.branch = branch
        self.arch = arch
        self.platform = platform
        self.personality = personality
        self.force = force
        self.dry_run = dry_run

        self.srcdir = SRCDIR
        self.datadir = os.path.join(self.srcdir, 'data')
        self.helpersdir = os.path.join(self.srcdir, 'helpers')
        self.builddir = eib.BUILDDIR
        self.tmpdir = os.path.join(self.builddir, 'tmp')
        self.ostree_tmpdir = os.path.join(self.tmpdir, 'ostree-bin')
        self.contentdir = os.path.join(self.builddir, 'content')
        self.apps_contentdir = os.path.join(self.contentdir, 'apps')
        self.outdir = os.path.join(self.builddir, 'out')
        self.cachedir = os.path.join(self.builddir, 'cache')
        self.sysconf = eib.SYSCONFDIR
        self.build_version = datetime.datetime.now().strftime('%y%m%d-%H%M%S')

    def configure(self):
        """Build settings determined from options"""
        # Architecture and platform
        if not self.arch:
            # Auto-detect from host arch
            machine = os.uname().machine
            if machine == 'x86_64' or fnmatch.fnmatch(machine, 'i?86'):
                self.arch = 'i386'
            elif machine.startswith('arm'):
                self.arch = 'armhf'
            else:
                raise ImageBuildError('Machine', machine, 'not supported')

        if self.arch not in self.SUPPORTED_ARCHES:
            raise ImageBuildError('Architecture', self.arch, 'not supported')

        if not self.platform:
            if self.arch == 'armhf':
                # Default to odroidu2 (should probably be ec100)
                self.platform = 'odroidu2'
            else:
                # Assume platform neutral arch
                self.platform = self.arch

        # Create 2 disk split images for everything except eosdev
        if self.product == 'eosdev':
            self.split_images = False
        else:
            self.split_images = True

        # Debian package repository from where OS packages will be obtained
        self.obs_repo = 'http://obs-master.endlessm-sf.com:82/shared/eos'

        # GPG private key ID for signing images
        self.image_signing_keyid = '587A279C'

        # OSTree defaults
        self.ostree_branch = '%s/%s' %(self.branch, self.platform)
        self.ostree_repo = '%s-%s' %(self.product, self.arch)
        self.ostree_os = self.product

        # The eos and eosnonfree products are handled a bit
        # counterintuitively. For both products, we want to continue
        # using the eos OS name. For eos, we will temporarily use a
        # separate repo called eosfree-$arch. For eosnonfree, it will
        # continue using the eos-$arch repo so our users with codecs
        # continue to get updates. Later, when the OS is clean again,
        # the eosfree-$arch repo will go away and both will use the
        # eos-$arch repo.
        if self.product == 'eos':
            self.ostree_repo = 'eosfree-' + self.arch
        elif self.product == 'eosnonfree':
            self.ostree_repo = 'eos-' + self.arch
            self.ostree_os = 'eos'

        # OSTree directories
        self.ostree = os.path.join(self.builddir, 'ostree', self.ostree_repo)
        self.ostree_checkout = os.path.join(self.builddir, 'ostree-co')

        # Multiple stable minor version branches may be in use, but the
        # deployed ostree configuration should use only the major
        # version. E.g., the real branch may be eos2.2, but the deployed
        # configuration should use eos2.
        self.ostree_branch_deploy = '%s/%s' %(self.branch.rsplit('.', 1)[0],
                                              self.platform)

        # The ostree URL that the final system will query for updates.
        # Not used during build time. The product (e.g. eos) and arch is
        # taken as a subdirectory of this address.
        ostree_url_root = 'https://endless:***REMOVED***@ostree.endlessm.com'
        if self.branch == 'master':
            ostree_url_base = '%s/staging/dev' %ostree_url_root
        else:
            ostree_url_base = '%s/ostree' % ostree_url_root
        self.ostree_url = '%s/%s' %(ostree_url_base, self.ostree_repo)

        # Internal ostree server URL. This is used to pull the most
        # recent commit.
        ostree_int_host = 'ostree.endlessm-sf.com'
        self.ostree_int_url = 'http://%s/%s' %(ostree_int_host, self.ostree_repo)

        # Image uploading
        self.image_host_short = 'obs-repository'
        self.image_host = '%s.endlessm-sf.com' % self.image_host_short
        self.image_user = 'uploader'
        self.image_path = '/srv/images/www'

        # Image URLs
        self.image_url_root = 'http://images.endlessm-sf.com/'

        # Email settings
        self.email_from = 'image-builder@endlessm.com'
        self.email_replyto = 'endless-dev@endlessm.com'
        self.email_to = 'endless-dev-status@endlessm.com'

        # Jenkins triggering
        self.jenkins_url = 'http://ci.endlessm-sf.com:8080'
        self.jenkins_user = 'image-builder'
        self.jenkins_token = os.path.join(self.sysconf, 'jenkins-token')

    def setenv(self, attr):
        """Export attribute as variable in EIB namespace"""
        value = getattr(self, attr)
        if isinstance(value, bool):
            value = 'true' if value else 'false'
        else:
            value = str(value)
        var = 'EIB_' + attr.upper()
        os.environ[var] = value

    def set_environment(self):
        """Setup environment variables for stages and hooks"""
        # Standard builder environment
        os.environ['EIB_SRC'] = self.srcdir
        os.environ['EIB_HELPERS'] = self.helpersdir
        os.environ['EIB_SCRATCH'] = self.builddir
        os.environ['EIB_DATA'] = self.datadir
        os.environ['EIB_TMPDIR'] = self.tmpdir
        os.environ['EIB_CONTENT'] = self.contentdir
        os.environ['EIB_APPS_CONTENT'] = self.apps_contentdir
        os.environ['EIB_OUT_ROOT'] = self.outdir
        os.environ['EIB_CACHEDIR'] = self.cachedir
        os.environ['EIB_BASELIB'] = os.path.join(self.srcdir, 'lib/eib.sh')
        os.environ['PATH'] = '%s:%s' %(os.path.join(self.srcdir, 'stages'),
                                       os.environ['PATH'])
        pypath = os.path.join(self.srcdir, 'lib')
        if 'PYTHONPATH' in os.environ:
            os.environ['PYTHONPATH'] = '%s:%s' %(pypath,
                                                 os.environ['PYTHONPATH'])
        else:
            os.environ['PYTHONPATH'] = pypath

        # Clean language settings
        os.environ['LANG'] = 'C'
        for langenv in ['LANGUAGE', 'LC_CTYPE', 'LC_NUMERIC', 'LC_TIME',
                        'LC_COLLATE', 'LC_MONETARY', 'LC_MESSAGES',
                        'LC_PAPER', 'LC_NAME', 'LC_ADDRESS', 'LC_TELEPHONE',
                        'LC_MEASUREMENT', 'LC_IDENTIFICATION', 'LC_ALL']:
            if langenv in os.environ:
                del os.environ[langenv]

        # Build specific environment attributes
        for attr in self.ENV_ATTRS:
            self.setenv(attr)

    def prep_builddir(self):
        """Cleanup the scratch space and prep for a new build"""
        # If the scratch space exists, unmount any filesystems in it and
        # make all paths mutable.
        if os.path.isdir(self.builddir):
            # Fully resolve the build path to match what's in the mount
            # info
            realdir = os.path.realpath(self.builddir)
            mounts = []
            with open('/proc/mounts') as mountf:
                for line in mountf:
                    mountdir = line.split()[1]
                    # Search for all mounts that begin with $builddir/.
                    # The trailing / is added for 2 reasons.
                    #
                    # 1. It makes sure that $builddir itself is not
                    # matched. If someone has mounted the build
                    # directory itself, that was probably done
                    # intentionally and wasn't done by the builder.
                    #
                    # 2. It ensures that only paths below $builddir are
                    # matched and not $builddir-backup or anything else
                    # that begins with the same characters.
                    if mountdir.startswith(self.builddir + '/'):
                        # Prepend to the list so submounts are at the
                        # beginning of the list
                        mounts.insert(0, mountdir)

            for path in mounts:
                subprocess.check_call(['umount', path])

            # Make everything mutable. This is only valid on files and
            # directories, so skip everything else.
            for root, dirs, files in os.walk(self.builddir, followlinks=False):
                # Make the directory itself mutable
                subprocess.check_call(['chattr', '-i', root])

                # Make real files in the directory mutable
                realfiles = []
                for f in files:
                    if os.path.isfile(f) and not os.path.islink(f):
                        realfiles.append(f)
                if len(realfiles) > 0:
                    subprocess.check_call(['chattr', '-i'] + realfiles)

        # Cleanup files from previous build
        eib.recreate_dir(self.outdir)
        eib.recreate_dir(self.ostree_checkout)
        eib.recreate_dir(self.tmpdir)

        # Create the content directory
        os.makedirs(self.contentdir, exist_ok=True)

    def run(self):
        self.configure()
        self.prep_builddir()
        self.set_environment()

        # Run the buildscript
        sys.stdout.flush()
        subprocess.check_call([os.path.join(self.srcdir, 'buildscript')])

        # Unless this is a dry run, the output files have been published
        # and can be deleted.
        if not self.dry_run:
            shutil.rmtree(self.outdir, ignore_errors=True)

def main():
    aparser = ArgumentParser(description='Build and publish images for Endless')
    eib.add_cli_options(aparser)
    args = aparser.parse_args()

    for personality in args.personalities.strip().split():
        builder = ImageBuilder(product=args.product,
                               branch=args.branch,
                               arch=args.arch,
                               platform=args.platform,
                               personality=personality,
                               force=args.force,
                               dry_run=args.dry_run)
        builder.run()

if __name__ == '__main__':
    main()
