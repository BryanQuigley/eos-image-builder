#!/usr/bin/python3 -u
# -*- mode: Python; coding: utf-8 -*-

# Endless image builder
#
# Copyright (C) 2014-2015  Endless Mobile, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from argparse import ArgumentParser
import datetime
import fnmatch
import glob
import os
import shutil
import subprocess
import sys

SRCDIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(1, os.path.join(SRCDIR, 'lib'))
import eib

class ImageBuilder(object):
    # Attributes to be exported to environment
    CONFIG_ATTRS = ['product', 'branch', 'arch', 'platform',
                    'personality', 'force', 'dry_run', 'series',
                    'srcdir', 'datadir', 'helpersdir', 'cachedir',
                    'tmpdir', 'contentdir', 'outrootdir', 'outdir',
                    'checkrootdir', 'checkdir', 'configdir',
                    'sysconfdir', 'build_version', 'outversion',
                    'tmpconfig', 'deb_host_gnu_cpu',
                    'deb_host_multiarch', 'ssh_options']
    BOOLEAN_ATTRS = ['force', 'dry_run']

    # Config options that will be merged together from multiple
    # $prefix_add_* and $prefix_del_* options. This is a list of
    # (section, prefix) tuples.
    CONFIG_MERGE_PREFIXES = [
        ('check', 'hooks'),
        ('content', 'hooks'),
        ('image', 'hooks'),
        ('image', 'settings'),
        ('image', 'settings_locks'),
        ('split', 'hooks'),
        ('flatpak', 'install'),
        ('flatpak', 'nosplit'),
        ('publish', 'hooks'),
        ('error', 'hooks'),
    ]

    def __getattr__(self, attr):
        """Proxy this object's attributes into the config object"""
        if attr in self.CONFIG_ATTRS:
            # Proxy through to the config object's default section
            if attr in self.BOOLEAN_ATTRS:
                return self.config.getboolean(self.config.defaultsect,
                                              attr)
            return self.config.get(self.config.defaultsect, attr)
        else:
            # Chain up for normal attribute access
            return super().__getattribute__(attr)

    def __setattr__(self, attr, value):
        """Proxy the value to the config object"""
        if attr in self.CONFIG_ATTRS:
            # Proxy through to the config object's default section
            if attr in self.BOOLEAN_ATTRS:
                self.config.setboolean(None, attr, value)
            else:
                self.config.set(None, attr, value)
        else:
            # Chain up for normal attribute setting
            super().__setattr__(attr, value)

    def __init__(self, product, branch, arch, platform, personality,
                 show_config=False, force=False, dry_run=False):
        # Create the config option first to allow the proxying between
        # it and this object's attributes.
        self.config = eib.ImageConfigParser()
        self.product = product
        self.branch = branch
        self.personality = personality
        self.show_config = show_config
        self.force = force
        self.dry_run = dry_run

        # Release series. E.g., eos2.4 is in series eos2 while master is
        # in series master.
        self.series = self.branch.rsplit('.', 1)[0]

        # Detect architecture and platform if not provided
        if arch:
            self.arch = arch
        else:
            machine = os.uname().machine
            if machine == 'x86_64':
                self.arch = 'amd64'
            elif fnmatch.fnmatch(machine, 'i?86'):
                self.arch = 'i386'
            elif machine.startswith('arm'):
                self.arch = 'armhf'
            else:
                raise eib.ImageBuildError('Machine', machine, 'not supported')

        if self.arch not in eib.SUPPORTED_ARCHES:
            raise eib.ImageBuildError('Architecture', self.arch, 'not supported')

        if platform:
            self.platform = platform
        else:
            if self.arch == 'armhf':
                # Default to odroidu2 (should probably be ec100)
                self.platform = 'odroidu2'
            else:
                # Assume platform neutral arch
                self.platform = self.arch

        # Load other common settings, but use the configparser
        # interpolation syntax. This will allow the user to override
        # things easily.
        self.srcdir = SRCDIR
        self.datadir = '${srcdir}/data'
        self.helpersdir = '${srcdir}/helpers'
        self.cachedir = eib.CACHEDIR
        self.builddir = eib.BUILDDIR
        self.tmpdir = '${cachedir}/tmp'
        self.contentdir = '${cachedir}/content'
        self.outrootdir = '${tmpdir}/out'
        self.outdir = '${outrootdir}/${personality}'
        self.checkrootdir = '${cachedir}/check'
        self.checkdir = '${checkrootdir}/${product}-${branch}-${arch}-${platform}/${personality}'
        self.configdir = '${srcdir}/config'
        self.sysconfdir = eib.SYSCONFDIR
        self.build_version = datetime.datetime.now().strftime('%y%m%d-%H%M%S')
        self.outversion = '${product}-${branch}-${arch}-${platform}.${build_version}.${personality}'
        self.tmpconfig = '${tmpdir}/config.ini'
        self.ssh_options = \
            '-i ${sysconfdir}/ssh-key.pem -o StrictHostKeyChecking=no'

        # Pull in dpkg-architecture settings that are needed for the
        # installation of flatpak bundles.
        gnu_cpu = subprocess.check_output(['dpkg-architecture',
                                           '-a' + self.arch,
                                           '-qDEB_HOST_GNU_CPU'])
        self.deb_host_gnu_cpu = gnu_cpu.decode().strip()
        multiarch = subprocess.check_output(['dpkg-architecture',
                                             '-a' + self.arch,
                                             '-qDEB_HOST_MULTIARCH'])
        self.deb_host_multiarch = multiarch.decode().strip()

    def configure(self):
        """Build settings from configuration files"""
        # Build up a list of config files to load. The order goes like so:
        #
        # 1. Default settings - $configdir/defaults.ini.
        # 2. Product, branch, arch, platform and personality settings.
        #    These are in $configdir subdirectories. For example,
        #    $configdir/product/$product.ini.
        # 3. System config settings - $sysconfdir/config.ini.
        # 4. Local user settings - $configdir/local.ini.
        config_files = [
            os.path.join(self.configdir, 'defaults.ini'),
            os.path.join(self.configdir, 'product', self.product + '.ini'),
            os.path.join(self.configdir, 'branch', self.branch + '.ini'),
            os.path.join(self.configdir, 'arch', self.arch + '.ini'),
            os.path.join(self.configdir, 'platform', self.platform + '.ini'),
            os.path.join(self.configdir, 'personality', self.personality + '.ini'),
            os.path.join(self.sysconfdir, 'config.ini'),
            os.path.join(self.configdir, 'local.ini'),
        ]
        for path in self.config.read(config_files):
            print('Loaded configuration file', path)

        # Handle merged key prefixes
        for section, prefix in self.CONFIG_MERGE_PREFIXES:
            self.config.merge_option_prefix(section, prefix)

    def check_value(self, section, option, value):
        # Sections and key names match the config files, with suffixes as
        # follows:
        #  _required = true means that the key must be set
        #  _values means the config value, if set, must be within the
        #          space-separated list of values in the schema
        if option.endswith('_required'):
            option = option[:-len('_required')]
            if value.lower() == 'true' and option not in self.config[section]:
                raise eib.ImageBuildError(
                    'Required configuration key [%s] %s is missing'
                    % (section, option))
        elif option.endswith('_values'):
            option = option[:-len('_values')]
            if option in self.config[section] and \
               self.config[section][option] not in value.split():
                raise eib.ImageBuildError(
                    'Configuration key [%s] %s has invalid value: %s'
                    % (section, option, self.config[section][option]))

    def check_config(self):
        """Check loaded configuration against schema for validity."""
        schema_file = os.path.join(self.configdir, 'schema.ini')
        schema = eib.ImageConfigParser()
        schema.read(schema_file)

        for option, value in schema.items(schema.defaultsect):
            self.check_value(schema.defaultsect, option, value)
        for sect in schema.sections():
            for option, value in schema.items_no_default(sect):
                self.check_value(sect, option, value)

    def setenv(self, section, option, value):
        """Export config values as variable in EIB namespace"""
        # Convert boolean's to true/false to be handled easily in shell
        if value in ['True', 'False']:
            value = value.lower()
        var = 'EIB_'
        if section:
            var += section.upper() + '_'
        var += option.upper()
        os.environ[var] = value

    def set_environment(self):
        """Setup environment variables for stages and hooks"""
        # Standard builder environment
        os.environ['EIB_BASELIB'] = os.path.join(SRCDIR, 'lib/eib.sh')
        os.environ['PATH'] = '%s:%s' %(os.path.join(SRCDIR, 'stages'),
                                       os.environ['PATH'])
        pypath = os.path.join(SRCDIR, 'lib')
        if 'PYTHONPATH' in os.environ:
            os.environ['PYTHONPATH'] = '%s:%s' %(pypath,
                                                 os.environ['PYTHONPATH'])
        else:
            os.environ['PYTHONPATH'] = pypath

        # Use our helper script for git access over ssh
        os.environ['GIT_SSH'] = os.path.join(self.helpersdir, 'git-ssh')

        # Clean language settings
        os.environ['LANG'] = 'C'
        for langenv in ['LANGUAGE', 'LC_CTYPE', 'LC_NUMERIC', 'LC_TIME',
                        'LC_COLLATE', 'LC_MONETARY', 'LC_MESSAGES',
                        'LC_PAPER', 'LC_NAME', 'LC_ADDRESS', 'LC_TELEPHONE',
                        'LC_MEASUREMENT', 'LC_IDENTIFICATION', 'LC_ALL']:
            if langenv in os.environ:
                del os.environ[langenv]

        # Build specific environment attributes.
        for option, value in self.config.items(self.config.defaultsect):
            self.setenv(None, option, value)
        for sect in self.config.sections():
            for option, value in self.config.items_no_default(sect):
                self.setenv(sect, option, value)

    def prep_builddir(self):
        """Cleanup the scratch space and prep for a new build"""
        ostree_co_dir = self.config['ostree']['checkout']

        # If the scratch space exists, unmount any filesystems in it and
        # make all paths mutable.
        if os.path.isdir(self.builddir):
            # Fully resolve the build path to match what's in the mount
            # info
            print('Cleaning up mounts in', self.builddir, flush=True)
            realdir = os.path.realpath(self.builddir)
            mounts = []
            with open('/proc/mounts') as mountf:
                for line in mountf:
                    mountdir = line.split()[1]
                    # Search for all mounts that begin with $builddir/.
                    # The trailing / is added for 2 reasons.
                    #
                    # 1. It makes sure that $builddir itself is not
                    # matched. If someone has mounted the build
                    # directory itself, that was probably done
                    # intentionally and wasn't done by the builder.
                    #
                    # 2. It ensures that only paths below $builddir are
                    # matched and not $builddir-backup or anything else
                    # that begins with the same characters.
                    if mountdir.startswith(realdir + '/'):
                        # Prepend to the list so submounts are at the
                        # beginning of the list
                        mounts.insert(0, mountdir)

            for path in mounts:
                print('Unmounting', path, flush=True)
                subprocess.check_call(['umount', path])

        # Make ostree checkouts mutable
        print('Ensuring all ostree checkouts mutable in', ostree_co_dir,
              flush=True)
        ostree_checkouts = os.path.join(ostree_co_dir,
                                        'ostree/deploy/*/deploy/*')
        for path in glob.iglob(ostree_checkouts):
            # Only directories are checkouts
            if os.path.isdir(path):
                subprocess.check_call(['chattr', '-i', path])

        # Cleanup files from previous build
        print('Recreating build specific temporary directories',
              flush=True)
        eib.recreate_dir(self.tmpdir)
        eib.recreate_dir(ostree_co_dir)

        # Create the content directory
        os.makedirs(self.contentdir, exist_ok=True)

    def create_tmp_config(self):
        """Take the merged configuration and output it to a single file
        in the tmp directory.
        """
        with open(self.tmpconfig, 'w') as out:
            out.write('# Configuration for %s\n' % self.outversion)
            self.config.write(out)

    def run(self):
        print('Configuring image build', flush=True)
        self.configure()
        self.check_config()
        if self.show_config:
            # Just show the configuration without doing anything
            self.config.write(sys.stdout)
            return

        print('Preparing build directory', flush=True)
        self.prep_builddir()
        print('Exporting configuration to environment', flush=True)
        self.set_environment()
        print('Output merged configuration file to', self.tmpconfig,
              flush=True)
        self.create_tmp_config()

        # Run the buildscript
        print('Running image buildscript', flush=True)
        subprocess.check_call([os.path.join(self.srcdir, 'buildscript')])

        # Unless this is a dry run, the output files have been published
        # and can be deleted.
        if not self.dry_run:
            print('Cleaning up output in', self.outrootdir, flush=True)
            shutil.rmtree(self.outrootdir, ignore_errors=True)

def main():
    aparser = ArgumentParser(description='Build and publish images for Endless')
    eib.add_cli_options(aparser)
    args = aparser.parse_args()

    for personality in args.personalities.strip().split():
        builder = ImageBuilder(product=args.product,
                               branch=args.branch,
                               arch=args.arch,
                               platform=args.platform,
                               personality=personality,
                               show_config=args.show_config,
                               force=args.force,
                               dry_run=args.dry_run)
        builder.run()

if __name__ == '__main__':
    main()
