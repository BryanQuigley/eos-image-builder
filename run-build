#!/usr/bin/python3
# -*- mode: Python; coding: utf-8 -*-

# Endless image builder
#
# Copyright (C) 2014-2015  Endless Mobile, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from argparse import ArgumentParser
import datetime
import fnmatch
import os
import shutil
import subprocess
import sys

SRCDIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(1, os.path.join(SRCDIR, 'lib'))
import eib

class ImageBuilder(object):
    # Attributes to be exported to environment
    CONFIG_ATTRS = ['product', 'branch', 'arch', 'platform',
                    'personality', 'force', 'dry_run', 'series',
                    'srcdir', 'datadir', 'helpersdir', 'builddir',
                    'tmpdir', 'ostree_tmpdir', 'contentdir',
                    'apps_contentdir', 'outrootdir', 'cachedir',
                    'sysconfdir', 'build_version']
    BOOLEAN_ATTRS = ['force', 'dry_run']
    SUPPORTED_ARCHES = ['i386', 'armhf']

    def __getattr__(self, attr):
        """Proxy this object's attributes into the config object"""
        if attr in self.CONFIG_ATTRS:
            # Proxy through to the config object's default section
            if attr in self.BOOLEAN_ATTRS:
                return self.config.getboolean(self.config.defaultsect,
                                              attr)
            return self.config.get(self.config.defaultsect, attr)
        else:
            # Chain up for normal attribute access
            return super().__getattribute__(attr)

    def __setattr__(self, attr, value):
        """Proxy the value to the config object"""
        if attr in self.CONFIG_ATTRS:
            # Proxy through to the config object's default section
            if attr in self.BOOLEAN_ATTRS:
                self.config.setboolean(None, attr, value)
            else:
                self.config.set(None, attr, value)
        else:
            # Chain up for normal attribute setting
            super().__setattr__(attr, value)

    def __init__(self, product, branch, arch, platform, personality,
                 force=False, dry_run=False):
        # Create the config option first to allow the proxying between
        # it and this object's attributes.
        self.config = eib.ImageConfigParser()
        self.product = product
        self.branch = branch
        self.personality = personality
        self.force = force
        self.dry_run = dry_run

        # Release series. E.g., eos2.4 is in series eos2 while master is
        # in series master.
        self.series = self.branch.rsplit('.', 1)[0]

        # Detect architecture and platform if not provided
        if arch:
            self.arch = arch
        else:
            machine = os.uname().machine
            if machine == 'x86_64' or fnmatch.fnmatch(machine, 'i?86'):
                self.arch = 'i386'
            elif machine.startswith('arm'):
                self.arch = 'armhf'
            else:
                raise ImageBuildError('Machine', machine, 'not supported')

        if self.arch not in self.SUPPORTED_ARCHES:
            raise ImageBuildError('Architecture', self.arch, 'not supported')

        if platform:
            self.platform = platform
        else:
            if self.arch == 'armhf':
                # Default to odroidu2 (should probably be ec100)
                self.platform = 'odroidu2'
            else:
                # Assume platform neutral arch
                self.platform = self.arch

        # Load other common settings, but use the configparser
        # interpolation syntax. This will allow the user to override
        # things easily.
        self.srcdir = SRCDIR
        self.datadir = '${srcdir}/data'
        self.helpersdir = '${srcdir}/helpers'
        self.builddir = eib.BUILDDIR
        self.tmpdir = '${builddir}/tmp'
        self.ostree_tmpdir = '${tmpdir}/ostree-bin'
        self.contentdir = '${builddir}/content'
        self.apps_contentdir = '${contentdir}/apps'
        self.outrootdir = '${builddir}/out'
        self.cachedir = '${builddir}/cache'
        self.sysconfdir = eib.SYSCONFDIR
        self.build_version = datetime.datetime.now().strftime('%y%m%d-%H%M%S')

    def configure(self):
        """Build settings determined from options"""
        # Add sections to the config
        for sect in ['image', 'ostree', 'email', 'jenkins']:
            self.config.add_section(sect)

        # Create 2 disk split images for everything except eosdev
        self.config.setboolean(None, 'split_images',
                               self.product != 'eosdev')

        # Debian package repository from where OS packages will be obtained
        self.config.set(None, 'obs_repo',
                        'http://obs-master.endlessm-sf.com:82/shared/eos')

        # GPG private key ID for signing images
        self.config['image']['signing_keyid'] = '587A279C'

        # OSTree defaults
        ostree = self.config['ostree']
        ostree['branch'] = '${build:branch}/${platform}'
        ostree['repo'] = '${product}-${arch}'
        ostree['os'] = '${product}'

        # The eos and eosnonfree products are handled a bit
        # counterintuitively. For both products, we want to continue
        # using the eos OS name. For eos, we will temporarily use a
        # separate repo called eosfree-$arch. For eosnonfree, it will
        # continue using the eos-$arch repo so our users with codecs
        # continue to get updates. Later, when the OS is clean again,
        # the eosfree-$arch repo will go away and both will use the
        # eos-$arch repo.
        if self.product == 'eos':
            ostree['repo'] = 'eosfree-${arch}'
        elif self.product == 'eosnonfree':
            ostree['repo'] = 'eos-${arch}'
            ostree['os'] = 'eos'

        # OSTree directories
        ostree['repodir'] = '${builddir}/ostree/${repo}'
        ostree['checkout'] = '${builddir}/ostree-co'

        # Multiple stable minor version branches may be in use, but the
        # deployed ostree configuration should use only the major
        # version. E.g., the real branch may be eos2.2, but the deployed
        # configuration should use eos2.
        ostree['branch_deploy'] = '${series}/${platform}'

        # The ostree URL that the final system will query for updates.
        # Not used during build time. The product (e.g. eos) and arch is
        # taken as a subdirectory of this address.
        ostree_url_root = 'https://endless:***REMOVED***@ostree.endlessm.com'
        if self.branch == 'master':
            ostree_url_base = '%s/staging/dev' %ostree_url_root
        else:
            ostree_url_base = '%s/ostree' % ostree_url_root
        ostree['url'] = '%s/${repo}' % ostree_url_base

        # Internal ostree server URL. This is used to pull the most
        # recent commit.
        ostree_int_host = 'ostree.endlessm-sf.com'
        ostree['int_url'] = 'http://%s/${repo}' % ostree_int_host

        # Image uploading
        image = self.config['image']
        image['host_short'] = 'obs-repository'
        image['host'] = '${host_short}.endlessm-sf.com'
        image['user'] = 'uploader'
        image['path'] = '/srv/images/www'

        # Image URLs
        image['url_root'] = 'http://images.endlessm-sf.com/'

        # Email settings
        email = self.config['email']
        email['from'] = 'image-builder@endlessm.com'
        email['replyto'] = 'endless-dev@endlessm.com'
        email['to'] = 'endless-dev-status@endlessm.com'

        # Jenkins triggering
        jenkins = self.config['jenkins']
        jenkins['url'] = 'http://ci.endlessm-sf.com:8080'
        jenkins['user'] = 'image-builder'
        jenkins['token'] = '${sysconfdir}/jenkins-token'

        # Now read in any system and local overrides.
        sysconfig = os.path.join(self.sysconfdir, 'config.ini')
        localconfig = os.path.join(self.srcdir, 'config', 'local.ini')
        for path in self.config.read([sysconfig, localconfig]):
            print('Loaded configuration file', path)

    def setenv(self, section, option, value):
        """Export config values as variable in EIB namespace"""
        # Convert boolean's to true/false to be handled easily in shell
        if value in ['True', 'False']:
            value = value.lower()
        var = 'EIB_'
        if section:
            var += section.upper() + '_'
        var += option.upper()
        os.environ[var] = value

    def set_environment(self):
        """Setup environment variables for stages and hooks"""
        # Standard builder environment
        os.environ['EIB_BASELIB'] = os.path.join(SRCDIR, 'lib/eib.sh')
        os.environ['PATH'] = '%s:%s' %(os.path.join(SRCDIR, 'stages'),
                                       os.environ['PATH'])
        pypath = os.path.join(SRCDIR, 'lib')
        if 'PYTHONPATH' in os.environ:
            os.environ['PYTHONPATH'] = '%s:%s' %(pypath,
                                                 os.environ['PYTHONPATH'])
        else:
            os.environ['PYTHONPATH'] = pypath

        # Clean language settings
        os.environ['LANG'] = 'C'
        for langenv in ['LANGUAGE', 'LC_CTYPE', 'LC_NUMERIC', 'LC_TIME',
                        'LC_COLLATE', 'LC_MONETARY', 'LC_MESSAGES',
                        'LC_PAPER', 'LC_NAME', 'LC_ADDRESS', 'LC_TELEPHONE',
                        'LC_MEASUREMENT', 'LC_IDENTIFICATION', 'LC_ALL']:
            if langenv in os.environ:
                del os.environ[langenv]

        # Build specific environment attributes.
        for option, value in self.config.items(self.config.defaultsect):
            self.setenv(None, option, value)
        for sect in self.config.sections():
            for option, value in self.config.items_no_default(sect):
                self.setenv(sect, option, value)

    def prep_builddir(self):
        """Cleanup the scratch space and prep for a new build"""
        # If the scratch space exists, unmount any filesystems in it and
        # make all paths mutable.
        if os.path.isdir(self.builddir):
            # Fully resolve the build path to match what's in the mount
            # info
            realdir = os.path.realpath(self.builddir)
            mounts = []
            with open('/proc/mounts') as mountf:
                for line in mountf:
                    mountdir = line.split()[1]
                    # Search for all mounts that begin with $builddir/.
                    # The trailing / is added for 2 reasons.
                    #
                    # 1. It makes sure that $builddir itself is not
                    # matched. If someone has mounted the build
                    # directory itself, that was probably done
                    # intentionally and wasn't done by the builder.
                    #
                    # 2. It ensures that only paths below $builddir are
                    # matched and not $builddir-backup or anything else
                    # that begins with the same characters.
                    if mountdir.startswith(self.builddir + '/'):
                        # Prepend to the list so submounts are at the
                        # beginning of the list
                        mounts.insert(0, mountdir)

            for path in mounts:
                subprocess.check_call(['umount', path])

            # Make everything mutable. This is only valid on files and
            # directories, so skip everything else.
            for root, dirs, files in os.walk(self.builddir, followlinks=False):
                # Make the directory itself mutable
                subprocess.check_call(['chattr', '-i', root])

                # Make real files in the directory mutable
                realfiles = []
                for f in files:
                    if os.path.isfile(f) and not os.path.islink(f):
                        realfiles.append(f)
                if len(realfiles) > 0:
                    subprocess.check_call(['chattr', '-i'] + realfiles)

        # Cleanup files from previous build
        eib.recreate_dir(self.outrootdir)
        eib.recreate_dir(self.config['ostree']['checkout'])
        eib.recreate_dir(self.tmpdir)

        # Create the content directory
        os.makedirs(self.contentdir, exist_ok=True)

    def run(self):
        self.configure()
        self.prep_builddir()
        self.set_environment()

        # Run the buildscript
        sys.stdout.flush()
        subprocess.check_call([os.path.join(self.srcdir, 'buildscript')])

        # Unless this is a dry run, the output files have been published
        # and can be deleted.
        if not self.dry_run:
            shutil.rmtree(self.outrootdir, ignore_errors=True)

def main():
    aparser = ArgumentParser(description='Build and publish images for Endless')
    eib.add_cli_options(aparser)
    args = aparser.parse_args()

    for personality in args.personalities.strip().split():
        builder = ImageBuilder(product=args.product,
                               branch=args.branch,
                               arch=args.arch,
                               platform=args.platform,
                               personality=personality,
                               force=args.force,
                               dry_run=args.dry_run)
        builder.run()

if __name__ == '__main__':
    main()
