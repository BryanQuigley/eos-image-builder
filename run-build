#!/usr/bin/python3 -u
# -*- mode: Python; coding: utf-8 -*-

# Endless image builder
#
# Copyright (C) 2014-2015  Endless Mobile, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from argparse import ArgumentParser
import datetime
import fnmatch
import glob
import os
import shutil
import subprocess
import sys

SRCDIR = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(1, os.path.join(SRCDIR, 'lib'))
import eib

class ImageBuildRoot(object):
    """Build root for performing actual image build

    A temporary build root is created with debootstrap at builddir. The
    options in the config section buildroot control what gets installed
    and mounted in the buildroot.
    """
    def __init__(self, builddir, config):
        self.builddir = builddir
        self.mounts = []

        # Get the config parameters
        arch = config['buildroot']['arch']
        repo = config['buildroot']['repo']
        codename = config['buildroot']['codename']
        components = config['buildroot']['components'].split()
        packages = config['buildroot']['packages'].split()
        script = config['buildroot']['script']
        keyring = config['build']['keyring']
        wanted_mounts = config['buildroot']['mounts'].split()
        aptcache_dir = config['buildroot']['aptcache_dir']
        aptcache_max_size = int(config['buildroot']['aptcache_max_size'])

        # Make sure the keyring is created
        eib.create_keyring(config)

        # Wipe the apt cache directory if it's grown too large.
        if os.path.exists(aptcache_dir):
            aptcache_size = eib.disk_usage(aptcache_dir)
            if aptcache_size >= aptcache_max_size:
                print('Apt cache directory uses', aptcache_size,
                      'bytes, removing')
                shutil.rmtree(aptcache_dir)

        # Mount aptcache_dir over the apt archives directory. Create the
        # full directory structure first before mounting so that it
        # remains valid after unmounting the cache directory.
        os.makedirs(os.path.join(self.builddir,
                                 'var/cache/apt/archives/partial'),
                    exist_ok=True)
        os.makedirs(os.path.join(aptcache_dir, 'partial'), exist_ok=True)
        self.mount(aptcache_dir, '/var/cache/apt/archives')

        print('Creating buildroot in', self.builddir)
        subprocess.check_call(['debootstrap',
                               '--arch=' + arch,
                               '--keyring=' + keyring,
                               '--variant=minbase',
                               '--include=' + ','.join(packages),
                               '--components=' + ','.join(components),
                               codename,
                               self.builddir,
                               repo,
                               script])

        # Mount all the desired paths
        for path in wanted_mounts:
            self.mount(path)

    def mount(self, path, target=None):
        """Bind mount path in the build directory"""
        if not os.path.isabs(path):
            raise eib.ImageBuildError('Buildroot mount path', path,
                                      'is not an absolute path')

        # Where it should be mounted
        if target is None:
            target = path
        elif not os.path.isabs(target):
            raise eib.ImageBuildError('Buildroot mount target', target,
                                      'is not an absolute path')
        mount_path = self.builddir + target

        print('Mounting', path, 'at', mount_path)
        os.makedirs(mount_path, exist_ok=True)
        subprocess.check_call(['mount', '--bind', path, mount_path])
        self.mounts.append(mount_path)

    def umount(self, target):
        """Unmount one path in the build directory"""
        if not os.path.isabs(target):
            raise eib.ImageBuildError('Buildroot mount target', target,
                                      'is not an absolute path')
        # Prepend the build directory if needed
        if not target.startswith(self.builddir + '/'):
            target = self.builddir + target
        if target not in self.mounts:
            raise eib.ImageBuildError(target, 'is not mounted in',
                                      self.builddir)
        print('Unmounting', target)
        subprocess.check_call(['umount', target])
        self.mounts.remove(target)

    def umount_all(self):
        """Unmount all paths in the build directory"""
        for mnt in reversed(self.mounts.copy()):
            print('Unmounting', mnt)
            subprocess.check_call(['umount', mnt])
            self.mounts.pop()

    def __enter__(self):
        return self

    def __exit__(self, exc, value, tb):
        self.umount_all()
        print('Removing buildroot', self.builddir)
        shutil.rmtree(self.builddir)

class ImageBuilder(object):
    # Attributes to be exported to environment
    CONFIG_ATTRS = ['product', 'branch', 'arch', 'platform',
                    'personality', 'force', 'dry_run', 'series',
                    'srcdir', 'datadir', 'helpersdir', 'cachedir',
                    'tmpdir', 'contentdir', 'outrootdir', 'outdir',
                    'checkrootdir', 'checkdir', 'checktmpdir',
                    'configdir', 'sysconfdir', 'build_version',
                    'outversion', 'tmpconfig', 'baselib',
                    'deb_host_gnu_cpu', 'deb_host_multiarch',
                    'ssh_options', 'keysdir', 'keyring', 'manifestdir',
                    'use_production']
    BOOLEAN_ATTRS = ['force', 'dry_run', 'use_production']

    # Config options that will be merged together from multiple
    # $prefix_add_* and $prefix_del_* options. This is a list of
    # (section, prefix) tuples.
    CONFIG_MERGE_PREFIXES = [
        ('buildroot', 'mounts'),
        ('buildroot', 'packages'),
        ('check', 'hooks'),
        ('content', 'hooks'),
        ('image', 'hooks'),
        ('image', 'icon_grid'),
        ('image', 'settings'),
        ('image', 'settings_locks'),
        ('split', 'hooks'),
        ('flatpak', 'install_eos'),
        ('flatpak', 'install_gnome'),
        ('flatpak', 'nosplit'),
        ('manifest', 'hooks'),
        ('publish', 'hooks'),
        ('error', 'hooks'),
    ]

    def __getattr__(self, attr):
        """Proxy this object's attributes into the config object"""
        if attr in self.CONFIG_ATTRS:
            # Proxy through to the config object's default section
            if attr in self.BOOLEAN_ATTRS:
                return self.config.getboolean(self.config.defaultsect,
                                              attr)
            return self.config.get(self.config.defaultsect, attr)
        else:
            # Chain up for normal attribute access
            return super().__getattribute__(attr)

    def __setattr__(self, attr, value):
        """Proxy the value to the config object"""
        if attr in self.CONFIG_ATTRS:
            # Proxy through to the config object's default section
            if attr in self.BOOLEAN_ATTRS:
                self.config.setboolean(None, attr, value)
            else:
                self.config.set(None, attr, value)
        else:
            # Chain up for normal attribute setting
            super().__setattr__(attr, value)

    def __init__(self, product, branch, arch, platform, personality,
                 show_config=False, force=False, dry_run=False,
                 use_production=False):
        # Create the config option first to allow the proxying between
        # it and this object's attributes.
        self.config = eib.ImageConfigParser()
        self.product = product
        self.branch = branch
        self.personality = personality
        self.show_config = show_config
        self.force = force
        self.dry_run = dry_run
        self.use_production = use_production

        # Release series. E.g., eos2.4 is in series eos2 while master is
        # in series master.
        self.series = self.branch.rsplit('.', 1)[0]

        # Detect architecture and platform if not provided
        if arch:
            self.arch = arch
        else:
            machine = os.uname().machine
            if machine == 'x86_64':
                self.arch = 'amd64'
            elif fnmatch.fnmatch(machine, 'i?86'):
                self.arch = 'i386'
            elif machine.startswith('arm'):
                self.arch = 'armhf'
            else:
                raise eib.ImageBuildError('Machine', machine, 'not supported')

        if self.arch not in eib.SUPPORTED_ARCHES:
            raise eib.ImageBuildError('Architecture', self.arch, 'not supported')

        if platform:
            self.platform = platform
        else:
            if self.arch == 'armhf':
                # Default to odroidu2 (should probably be ec100)
                self.platform = 'odroidu2'
            else:
                # Assume platform neutral arch
                self.platform = self.arch

        # Load other common settings, but use the configparser
        # interpolation syntax. This will allow the user to override
        # things easily.
        self.srcdir = SRCDIR
        self.datadir = '${srcdir}/data'
        self.helpersdir = '${srcdir}/helpers'
        self.cachedir = eib.CACHEDIR
        self.builddir = eib.BUILDDIR
        self.tmpdir = '${cachedir}/tmp'
        self.contentdir = '${cachedir}/content'
        self.outrootdir = '${tmpdir}/out'
        self.outdir = '${outrootdir}/${personality}'
        self.checkrootdir = '${cachedir}/check'
        self.checkdir = '${checkrootdir}/${product}-${branch}-${arch}-${platform}/${personality}'
        self.checktmpdir = '${tmpdir}/check'
        self.configdir = '${srcdir}/config'
        self.sysconfdir = eib.SYSCONFDIR
        self.build_version = datetime.datetime.utcnow().strftime('%y%m%d-%H%M%S')
        self.outversion = '${product}-${branch}-${arch}-${platform}.${build_version}.${personality}'
        self.tmpconfig = '${tmpdir}/config.ini'
        self.baselib = '${srcdir}/lib/eib.sh'
        self.ssh_options = \
            '-i ${sysconfdir}/ssh-key.pem -o StrictHostKeyChecking=no'
        self.keysdir = '${datadir}/keys'
        self.keyring = '${tmpdir}/eib-keyring.gpg'
        self.manifestdir = '${tmpdir}/manifest'

        # Pull in dpkg-architecture settings that are needed for the
        # installation of flatpak bundles.
        gnu_cpu = subprocess.check_output(['dpkg-architecture',
                                           '-a' + self.arch,
                                           '-qDEB_HOST_GNU_CPU'])
        self.deb_host_gnu_cpu = gnu_cpu.decode().strip()
        multiarch = subprocess.check_output(['dpkg-architecture',
                                             '-a' + self.arch,
                                             '-qDEB_HOST_MULTIARCH'])
        self.deb_host_multiarch = multiarch.decode().strip()

    def configure(self):
        """Build settings from configuration files"""
        # Build up a list of config files to load. The order goes like so:
        #
        # 1. Default settings - $configdir/defaults.ini.
        # 2. Product, branch, arch, platform and personality settings.
        #    These are in $configdir subdirectories. For example,
        #    $configdir/product/$product.ini.
        # 3. System config settings - $sysconfdir/config.ini.
        # 4. Local user settings - $configdir/local.ini.
        config_files = [
            os.path.join(self.configdir, 'defaults.ini'),
            os.path.join(self.configdir, 'product', self.product + '.ini'),
            os.path.join(self.configdir, 'branch', self.branch + '.ini'),
            os.path.join(self.configdir, 'arch', self.arch + '.ini'),
            os.path.join(self.configdir, 'platform', self.platform + '.ini'),
            os.path.join(self.configdir, 'personality', self.personality + '.ini'),
            os.path.join(self.sysconfdir, 'config.ini'),
            os.path.join(self.configdir, 'local.ini'),
        ]
        for path in self.config.read(config_files):
            print('Loaded configuration file', path)

        # Handle merged key prefixes
        for section, prefix in self.CONFIG_MERGE_PREFIXES:
            self.config.merge_option_prefix(section, prefix)

    def check_value(self, section, option, value):
        # Sections and key names match the config files, with suffixes as
        # follows:
        #  _required = true means that the key must be set
        #  _values means the config value, if set, must be within the
        #          space-separated list of values in the schema
        if option.endswith('_required'):
            option = option[:-len('_required')]
            if value.lower() == 'true' and option not in self.config[section]:
                raise eib.ImageBuildError(
                    'Required configuration key [%s] %s is missing'
                    % (section, option))
        elif option.endswith('_values'):
            option = option[:-len('_values')]
            if option in self.config[section] and \
               self.config[section][option] not in value.split():
                raise eib.ImageBuildError(
                    'Configuration key [%s] %s has invalid value: %s'
                    % (section, option, self.config[section][option]))

    def check_config(self):
        """Check loaded configuration against schema for validity."""
        schema_file = os.path.join(self.configdir, 'schema.ini')
        schema = eib.ImageConfigParser()
        schema.read(schema_file)

        for option, value in schema.items(schema.defaultsect):
            self.check_value(schema.defaultsect, option, value)
        for sect in schema.sections():
            for option, value in schema.items_no_default(sect):
                self.check_value(sect, option, value)

    def setenv(self, section, option, value):
        """Export config values as variable in EIB namespace"""
        # Convert boolean's to true/false to be handled easily in shell
        if value in ['True', 'False']:
            value = value.lower()
        var = 'EIB_'
        if section:
            var += section.upper() + '_'
        var += option.upper()
        os.environ[var] = value

    def set_environment(self):
        """Setup environment variables for stages and hooks"""
        # Build specific environment attributes.
        for option, value in self.config.items(self.config.defaultsect):
            self.setenv(None, option, value)
        for sect in self.config.sections():
            for option, value in self.config.items_no_default(sect):
                self.setenv(sect, option, value)

    def prep_builddir(self):
        """Cleanup the scratch space and prep for a new build"""
        ostree_co_dir = self.config['ostree']['checkout']

        # If the scratch space exists, unmount any filesystems in it and
        # make all paths mutable.
        if os.path.isdir(self.builddir) or os.path.isdir(self.cachedir):
            # Fully resolve the build path to match what's in the mount
            # info
            print('Cleaning up mounts in', self.builddir, 'and',
                  self.cachedir, flush=True)
            real_builddir = os.path.realpath(self.builddir)
            real_cachedir = os.path.realpath(self.cachedir)

            # Re-read the mount table after every unmount in case there
            # are aliased mounts
            while True:
                path = None
                with open('/proc/self/mountinfo') as mountf:
                    # Read the mounts backwards to unmount submounts
                    # first
                    for line in reversed(mountf.readlines()):
                        mountdir = line.split()[4]
                        # Search for mounts that begin with $dir/. The
                        # trailing / is added for 2 reasons.
                        #
                        # 1. It makes sure that $dir itself is not
                        # matched. If someone has mounted the build
                        # directory itself, that was probably done
                        # intentionally and wasn't done by the builder.
                        #
                        # 2. It ensures that only paths below $dir are
                        # matched and not $dir-backup or anything else
                        # that begins with the same characters.
                        if mountdir.startswith(real_builddir + '/') or \
                           mountdir.startswith(real_cachedir + '/'):
                            path = mountdir
                            break

                if path is None:
                    # No more paths to unmount
                    break

                print('Unmounting', path, flush=True)
                subprocess.check_call(['umount', path])

        # Make ostree checkouts mutable
        print('Ensuring all ostree checkouts mutable in', ostree_co_dir,
              flush=True)
        ostree_checkouts = os.path.join(ostree_co_dir,
                                        'ostree/deploy/*/deploy/*')
        for path in glob.iglob(ostree_checkouts):
            # Only directories are checkouts
            if os.path.isdir(path):
                subprocess.check_call(['chattr', '-i', path])

        # Cleanup files from previous build
        print('Recreating build specific temporary directories',
              flush=True)
        eib.recreate_dir(self.builddir)
        eib.recreate_dir(self.tmpdir)
        eib.recreate_dir(self.manifestdir)
        eib.recreate_dir(ostree_co_dir)

        # Create the content directory
        os.makedirs(self.contentdir, exist_ok=True)

    def create_tmp_config(self):
        """Take the merged configuration and output it to a single file
        in the tmp directory.
        """
        with open(self.tmpconfig, 'w') as out:
            out.write('# Configuration for %s\n' % self.outversion)
            self.config.write(out)

    def run(self):
        print('Configuring image build', flush=True)
        self.configure()
        self.check_config()
        if self.show_config:
            # Just show the configuration without doing anything
            self.config.write(sys.stdout)
            return

        if self.use_production:
            print('Using production ostree/flatpak repo')

        print('Preparing build directory', flush=True)
        self.prep_builddir()
        print('Exporting configuration to environment', flush=True)
        self.set_environment()
        print('Output merged configuration file to', self.tmpconfig,
              flush=True)
        self.create_tmp_config()
        print('Creating temporary GPG keyring', self.keyring)
        eib.create_keyring(self.config)

        # Run the buildscript in a buildroot
        with ImageBuildRoot(self.builddir, self.config):
              print('Running image buildscript')
              chrootscript = os.path.join(self.helpersdir, 'eib-chroot')
              buildscript = os.path.join(self.srcdir, 'buildscript')
              subprocess.check_call([chrootscript, self.builddir,
                                     buildscript])

        # Unless this is a dry run, the output files have been published
        # and can be deleted.
        if not self.dry_run:
            print('Cleaning up output in', self.outrootdir, flush=True)
            shutil.rmtree(self.outrootdir, ignore_errors=True)

def main():
    aparser = ArgumentParser(description='Build and publish images for Endless')
    eib.add_cli_options(aparser)
    args = aparser.parse_args()

    for personality in args.personalities.strip().split():
        builder = ImageBuilder(product=args.product,
                               branch=args.branch,
                               arch=args.arch,
                               platform=args.platform,
                               personality=personality,
                               show_config=args.show_config,
                               force=args.force,
                               dry_run=args.dry_run,
                               use_production=args.use_production)
        builder.run()

if __name__ == '__main__':
    main()
