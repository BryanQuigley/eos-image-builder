#!/bin/bash -ex
# -*- mode: Shell-script; sh-basic-offset: 2; indent-tabs-mode: nil -*-
export EIB_SRC=$(dirname $(readlink -f $0))
export EIB_SYSCONF=/etc/eos-image-builder
export EIB_BASELIB="${EIB_SRC}"/lib/eib.sh
export PATH=$EIB_SRC/stages:$PATH
export PYTHONPATH=$EIB_SRC/lib

export LANG=C
unset LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
unset LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
unset LC_ALL

# Make sure ERR traps follow through to shell functions
set -E

usage() {
  cat <<EOF
Usage: eos-image-builder [OPTION]... [BRANCH]
Build and publish images for Endless

  -p, --product         product to build
  --platform            platform to build
  -P, --personalities   personalities to build
  -f, --force           run build even when no new assets found
  -n, --dry-run         don't publish images
  --no-checkout         use current builder branch
  -h, --help            display this help and exit

If BRANCH is not specified, master is used.
EOF
}

args=$(getopt -o "p:P:fnh" \
  -l "product:,platform:,personalities:,force,dry-run,no-checkout,help" \
  -n "eos-image-builder" -- "$@")
eval set -- "${args}"

while true; do
  case "$1" in
    -p|--product)
      EIB_PRODUCT=$2
      shift 2
      ;;
    --platform)
      EIB_PLATFORM=$2
      shift 2
      ;;
    -P|--personalities)
      EIB_PERSONALITIES=$2
      shift 2
      ;;
    -f|--force)
      export EIB_FORCE=true
      shift
      ;;
    -n|--dry-run)
      export EIB_DRY_RUN=true
      shift
      ;;
    --no-checkout)
      # Ignored, only used in top level script
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
  esac
done

# Some configuration defaults
# Debian package repository from where OS packages will be obtained
export EIB_OBS_REPO=http://obs-master.endlessm-sf.com:82/shared/eos

export EIB_BRANCH=${1:-master}
export EIB_PRODUCT=${EIB_PRODUCT:-eos}

# GPG private key ID for signing images
export EIB_IMAGE_SIGNING_KEYID=587A279C

case "$(uname -m)" in
  x86_64|i?86)
    export EIB_ARCH=i386
    export EIB_PLATFORM=${EIB_PLATFORM:-i386}
    ;;

  arm*)
    export EIB_ARCH=armhf
    export EIB_PLATFORM=${EIB_PLATFORM:-odroidu2}
    ;;
esac

# By default, only the base personality image is built.
export EIB_PERSONALITIES=${EIB_PERSONALITIES:-base}

# Create 2 disk split images for everything except eosdev.
case "${EIB_PRODUCT}" in
  eosdev)
    EIB_SPLIT_IMAGES=false
    ;;
  *)
    EIB_SPLIT_IMAGES=true
    ;;
esac
export EIB_SPLIT_IMAGES

export EIB_BUILD_VERSION=$(date +%y%m%d-%H%M%S)
export EIB_OSTREE_BRANCH=${EIB_BRANCH}/${EIB_PLATFORM}
export EIB_OSTREE_REPO=${EIB_PRODUCT}-${EIB_ARCH}
export EIB_OSTREE_OS=${EIB_PRODUCT}

# The eos and eosnonfree products are handled a bit counterintuitively.
# For both products, we want to continue using the eos OS name. For eos,
# we will temporarily use a separate repo called eosfree-$arch. For
# eosnonfree, it will continue using the eos-$arch repo so our users
# with codecs continue to get updates. Later, when the OS is clean
# again, the eosfree-$arch repo will go away and both will use the
# eos-$arch repo.
case "${EIB_PRODUCT}" in
  eos)
    EIB_OSTREE_REPO=eosfree-${EIB_ARCH}
    ;;
  eosnonfree)
    EIB_OSTREE_REPO=eos-${EIB_ARCH}
    EIB_OSTREE_OS=eos
    ;;
esac

# Multiple stable minor version branches may be in use, but the deployed
# ostree configuration should use only the major version. E.g., the real
# branch may be eos2.2, but the deployed configuration should use eos2.
export EIB_OSTREE_BRANCH_DEPLOY=${EIB_BRANCH%.*}/${EIB_PLATFORM}

# The ostree URL that the final system will query for updates. Not used
# during build time. The product (e.g. eos) and arch is taken as a
# subdirectory of this address.
export EIB_OSTREE_URL_ROOT="https://endless:***REMOVED***@ostree.endlessm.com"
if [[ "${EIB_BRANCH}" == "master" ]]; then
  export EIB_OSTREE_URL_BASE="${EIB_OSTREE_URL_ROOT}/staging/dev"
else
  export EIB_OSTREE_URL_BASE="${EIB_OSTREE_URL_ROOT}/ostree"
fi
export EIB_OSTREE_URL=${EIB_OSTREE_URL_BASE}/${EIB_OSTREE_REPO}

# Internal ostree server URL. This is used to pull the most recent
# commit.
export EIB_OSTREE_INT_HOST=ostree.endlessm-sf.com
export EIB_OSTREE_INT_USER=uploader
export EIB_OSTREE_INT_DIR="/srv/ostree/www/${EIB_OSTREE_REPO}"
export EIB_OSTREE_INT_URL="http://${EIB_OSTREE_INT_HOST}/${EIB_OSTREE_REPO}"

# Image uploading
export EIB_IMAGE_HOST_SHORT=obs-repository
export EIB_IMAGE_HOST=${EIB_IMAGE_HOST_SHORT}.endlessm-sf.com
export EIB_IMAGE_USER=uploader
export EIB_IMAGE_PATH=/srv/images/www
export EIB_IMAGE_DEST=${EIB_IMAGE_PATH}/${EIB_PRODUCT}-${EIB_ARCH}-${EIB_PLATFORM}/${EIB_BRANCH}/${EIB_BUILD_VERSION}

# Image URLs
EIB_IMAGE_URL_ROOT="http://images.endlessm-sf.com/"
EIB_IMAGE_URL_BASE="${EIB_IMAGE_URL_ROOT}/${EIB_PRODUCT}-${EIB_ARCH}-${EIB_PLATFORM}/${EIB_BRANCH}/${EIB_BUILD_VERSION}"
export EIB_IMAGE_URL_ROOT EIB_IMAGE_URL_BASE

# Email settings
EIB_EMAIL_FROM=image-builder@endlessm.com
EIB_EMAIL_REPLYTO=endless-dev@endlessm.com
EIB_EMAIL_TO=endless-dev-status@endlessm.com
export EIB_EMAIL_FROM EIB_EMAIL_REPLYTO EIB_EMAIL_TO

# Jenkins triggering
EIB_JENKINS_URL="http://ci.endlessm-sf.com:8080"
EIB_JENKINS_USER=image-builder
EIB_JENKINS_TOKEN="${EIB_SYSCONF}"/jenkins-token
export EIB_JENKINS_URL EIB_JENKINS_USER EIB_JENKINS_TOKEN

# Read system config overrides
[[ -e "${EIB_SYSCONF}"/config ]] && . "${EIB_SYSCONF}"/config

# Read user config overrides
[[ -e "${EIB_SRC}"/config ]] && . "${EIB_SRC}"/config

. "${EIB_BASELIB}"

recreate_dir "${EIB_OUTDIR}"
recreate_dir "${EIB_TMPDIR}"
exec > >(tee $(eib_outfile build.txt))
exec 2>&1

mkdir -p "${EIB_CONTENT}"
. "${EIB_SRC}"/buildscript

# Unless this is a dry run, the output files have been published and can
# be deleted.
[ -n "${EIB_DRY_RUN}" ] || rm -rf "${EIB_OUTDIR}"
