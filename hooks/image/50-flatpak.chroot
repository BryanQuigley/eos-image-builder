#!/usr/bin/python3 -u

# Configure the image's flatpak remotes and install flatpaks using
# eibflatpak.FlatpakManager.

import eib
import eibflatpak
import logging
import os
import sys
from gi import require_version
require_version('Flatpak', '1.0')
require_version('OSTree', '1.0')
from gi.repository import Flatpak, Gio  # noqa: E402

logger = logging.getLogger(os.path.basename(__file__))
eib.setup_logging()
config = eib.get_config()

if not config.getboolean('flatpak', 'enable', fallback=True):
    sys.exit(0)

# Enable debug logging for all flatpak operations
os.environ['G_MESSAGES_DEBUG'] = 'flatpak'

# Skip flatpak parental controls checks when running from
# the builder - see https://phabricator.endlessm.com/T27896.
os.environ['FLATPAK_SKIP_PARENTAL_CONTROLS_NO_SYSTEM_BUS'] = '1'

# Make sure we set the correct XDG_DATA_DIRS when installing, or the
# triggers won't work properly. Normally these are always set when
# running in a session, but may not on Jenkins. See also
# /etc/profile.d/flatpak.sh.
data_dirs = ':'.join(['/var/lib/flatpak/exports/share/',
                      '/var/endless-extra/flatpak/exports/share/',
                      '/usr/share/'])
os.environ['XDG_DATA_DIRS'] = data_dirs

# Settings and paths. Need to use environment variables for paths to
# respect chroot mount locations.
content_repo = os.path.join(os.environ['EIB_CONTENTDIR'],
                            'flatpak/repo')
hook_group = os.environ['EIB_HOOK_GROUP']
if hook_group == 'split':
    installation_path = os.path.join(os.environ['EIB_EXTRA_MOUNT'],
                                     'flatpak')
    split_refs = True
else:
    installation_path = '/var/lib/flatpak'
    split_refs = False

# Open the flatpak installation and pass it to the manager
logger.info('Opening flatpak installation %s', installation_path)
installation_file = Gio.File.new_for_path(installation_path)
installation = Flatpak.Installation.new_for_path(installation_file,
                                                 user=False)
manager = eibflatpak.FlatpakManager(installation, config=config)
manager.add_remotes()
manager.enumerate_remotes()
manager.resolve_refs(split=split_refs)

# Pull the install refs using the content repo as a cache without making
# refs in case the resolved refs aren't the same as the installation
# uses
manager.pull(commit_only=True, cache_repo_path=content_repo)

# Install everything
manager.install()

# Finalize the remote URLs now that everything has been installed
manager.deploy_remotes()

# Prune the installation to drop unused refs and objects
logger.info('Cleaning up installation %s', installation_path)
installation.cleanup_local_refs_sync()

# Due to a bug which is not yet fully diagnosed, Flatpak sometimes writes refs
# at refs/mirrors/$COLLECTION_ID/$REF as well as refs/remotes/$REMOTE/$REF, but
# it does not remove the former when uninstalling the app/runtime, causing its
# disk space to be (effectively) leaked.
#
# TODO: fix Flatpak to consistently handle these collection ID-based refs, then
# remove this hack.
refs_mirrors_path = os.path.join(installation_path, "repo", "refs", "mirrors")
refs_remotes_path = os.path.join(installation_path, "repo", "refs", "remotes")

if os.path.isdir(refs_mirrors_path):
    logger.info("Cleaning up p2p refs in %s", refs_mirrors_path)

    remote_for_collection_id = {
        remote.get_collection_id(): remote.get_name()
        for remote in installation.list_remotes()
        if remote.get_collection_id() is not None
    }

    refs_mirrors_fd = os.open(refs_mirrors_path, os.O_RDONLY)
    for root, dirs, files, rootfd in os.fwalk(
        dir_fd=refs_mirrors_fd, topdown=False,
    ):
        bits = root.split(os.path.sep)
        assert bits[0] == "."
        if len(bits) > 1:
            collection_id = bits[1]
            remote = remote_for_collection_id[collection_id]
            remote_root = os.path.join(refs_remotes_path, remote, *bits[2:])

            for filename in files:
                remote_ref = os.path.join(remote_root, filename)
                mirror_ref = os.path.join(refs_mirrors_path, root, filename)
                if not os.path.exists(remote_ref):
                    raise eibflatpak.FlatpakError(
                        f"{mirror_ref} exists, but {remote_ref} does not"
                    )
                print(f"Removing {mirror_ref} since {remote_ref} exists")
                os.unlink(filename, dir_fd=rootfd)
        elif files:
            # This is just the refs/mirrors/ directory itself. We don't expect
            # any files here, only directories named after collection IDs.
            raise eibflatpak.FlatpakError(
                f"Unexpected files in {root}:", *files
            )

        for dirname in dirs:
            os.rmdir(dirname, dir_fd=rootfd)

    os.rmdir(refs_mirrors_path)

installation.prune_local_repo()
