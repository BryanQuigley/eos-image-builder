#!/usr/bin/python3
from kolibri.utils.cli import initialize

initialize()

import click

from datetime import datetime

from kolibri.core.content.models import ChannelMetadata
from kolibri.core.content.models import ContentNode
from kolibri.dist.django.db.models import Q


@click.command()
@click.argument("output", type=click.File("w"))
@click.option(
    "-i",
    "--include-channel",
    "include_channel_ids",
    multiple=True,
    default=[],
    metavar="CHANNEL",
    help="Include CHANNEL in the output",
)
@click.option(
    "-x",
    "--exclude-channel",
    "exclude_channel_ids",
    multiple=True,
    default=[],
    metavar="CHANNEL",
    help="Exclude CHANNEL from the output",
)
@click.option(
    "--pick-list-channel",
    "pick_list_channel_ids",
    multiple=True,
    default=[],
    metavar="CHANNEL",
    help="Use CHANNEL as a pick list",
)
def main(output, pick_list_channel_ids, include_channel_ids, exclude_channel_ids):
    """
    Generates endless-image-builder configuration to replicate the selection of
    Kolibri channels and content from $KOLIBRI_HOME.

    By default, the generated configuration file will include every content
    node that is available in every channel that is installed. It is possible
    to override this behaviour by specifying --include-channel or
    --exclude-channel.

    It is possible to use a channel as a pick list by specifying
    --pick-list-channel. In this case, matching content from the pick list
    channel will be treated as available in other channels. This is useful for
    situations where Kolibri content is curated with a new channel in Kolibri
    Studio, but in a final product we wish to have the content presented in
    its original channels.

    <https://github.com/endlessm/eos-image-builder/>
    """

    if include_channel_ids:
        channelmetadata_query = ChannelMetadata.objects.filter(
            id__in=include_channel_ids
        )
    else:
        channelmetadata_query = ChannelMetadata.objects.exclude(
            id__in=pick_list_channel_ids + exclude_channel_ids
        )

    if pick_list_channel_ids:
        content_selection = ContentSelection_ByPickList(pick_list_channel_ids)
    else:
        content_selection = ContentSelection_ByAvailable()

    content_by_channel = dict()
    for channelmetadata in channelmetadata_query:
        pick_nodes = content_selection.query_contentnodes_for_channel(
            channelmetadata.id
        )
        if pick_nodes.exists():
            content_by_channel[channelmetadata] = pick_nodes

    output.write("# Generated by kolibri-eib-configuration-generator\n")
    output.write("# {datetime}\n".format(datetime=datetime.now()))
    output.write("\n")

    output.write("[kolibri]\n")
    output.write("install_channels =\n")
    for channelmetadata, pick_nodes in content_by_channel.items():
        channel_comment_str = "{channel} [{nodes}]".format(
            channel=channelmetadata.name, nodes=pick_nodes.count()
        )
        output.write("  # {comment}\n".format(comment=channel_comment_str))
        output.write("  {channel_id}\n".format(channel_id=channelmetadata.id))
    output.write("\n")

    for channelmetadata, pick_nodes in content_by_channel.items():
        channel_configuration = ChannelConfiguration(channelmetadata)
        channel_configuration.select_content(pick_nodes)
        channel_configuration.write(output)


class ContentSelection(object):
    def query_contentnodes_for_channel(self, channel_id):
        raise NotImplementedError()

    def has_contentnodes_for_channel(self, channel_id):
        return self.query_contentnodes_for_channel(channel_id).exists()


class ContentSelection_ByAvailable(ContentSelection):
    def query_contentnodes_for_channel(self, channel_id):
        return ContentNode.objects.filter(
            channel_id=channel_id, available=True
        ).exclude(kind="topic")


class ContentSelection_ByPickList(ContentSelection):
    def __init__(self, pick_list_channel_ids, or_available=True):
        self.__pick_contentnode_query = ContentNode.objects.filter(
            channel_id__in=pick_list_channel_ids
        ).exclude(kind="topic")
        self.__or_available = or_available

    def query_contentnodes_for_channel(self, channel_id):
        # When using a pick list, we will treat content in another channel as
        # available if it has the same content ID as content in the pick list,
        # and it has the same parent content ID as content in the pick list.
        q = Q(
            content_id__in=self.__pick_contentnode_content_ids,
            parent__content_id__in=self.__pick_contentnode_parent_content_ids,
        )
        if self.__or_available:
            q |= Q(available=True)
        return (
            ContentNode.objects.filter(channel_id=channel_id)
            .filter(q)
            .exclude(kind="topic")
        )

    @property
    def __pick_contentnode_content_ids(self):
        return self.__pick_contentnode_query.values("content_id")

    @property
    def __pick_contentnode_parent_content_ids(self):
        return ContentNode.objects.filter(
            id__in=self.__pick_contentnode_query.values("parent")
        ).values("content_id")


class ChannelConfiguration(object):
    def __init__(self, channelmetadata):
        self.__channelmetadata = channelmetadata
        self.__include_nodes = set()
        self.__exclude_nodes = set()

    @property
    def include_nodes(self):
        return sorted(self.__include_nodes, key=lambda node: node.lft)

    @property
    def exclude_nodes(self):
        return sorted(self.__exclude_nodes, key=lambda node: node.lft)

    def select_content(self, pick_nodes):
        self.__include_nodes.clear()
        self.__exclude_nodes.clear()

        pick_nodes_queue = [self.__channelmetadata.root]

        while len(pick_nodes_queue) > 0:
            node = pick_nodes_queue.pop(0)

            # TODO: It would be nice if we add nodes to exclude_nodes when
            #       less than half of sibling nodes are missing.

            if node.kind == "topic":
                leaf_nodes = self.__get_leaf_nodes(node)
                matching_leaf_nodes = set(leaf_nodes).intersection(pick_nodes)
                missing_leaf_nodes = set(leaf_nodes).difference(pick_nodes)
                if len(missing_leaf_nodes) == 0:
                    self.__include_nodes.add(node)
                elif len(matching_leaf_nodes) > 0:
                    pick_nodes_queue.extend(node.children.all())
            elif node in pick_nodes:
                self.__include_nodes.add(node)

    def write(self, output):
        if not self.include_nodes and not self.exclude_nodes:
            return

        output.write("[kolibri-{}]\n".format(self.__channelmetadata.id))
        self.__write_node_list(self.include_nodes, "include_node_ids", output)
        self.__write_node_list(self.exclude_nodes, "exclude_node_ids", output)
        output.write("\n")

    def __write_node_list(self, nodes, key, output):
        if not nodes:
            return
        output.write("{key} =\n".format(key=key))
        for node in nodes:
            output.write(
                "  # {comment}\n".format(comment=self.__node_comment_str(node))
            )
            output.write("  {id}\n".format(id=node.id))

    def __node_comment_str(self, node):
        if node.kind == "topic":
            return "{title} [topic - {children}]".format(
                title=node.title, children=self.__get_leaf_nodes(node).count()
            )
        else:
            return "{title} [{kind}]".format(title=node.title, kind=node.kind)

    def __get_leaf_nodes(self, node):
        return ContentNode.objects.filter(
            lft__gte=node.lft, lft__lte=node.rght, channel_id=node.channel_id
        ).exclude(kind="topic")


if __name__ == "__main__":
    main()
